[
  {
    "url": "https://github.com/langchain-ai/langgraphjs/blob/main/libs/langgraph/src/pregel/algo.ts",
    "markdown": "/* eslint-disable no-param-reassign */\nimport {\n  mergeConfigs,\n  patchConfig,\n  RunnableConfig,\n} from \"@langchain/core/runnables\";\nimport { CallbackManagerForChainRun } from \"@langchain/core/callbacks/manager\";\nimport {\n  All,\n  BaseCheckpointSaver,\n  Checkpoint,\n  ReadonlyCheckpoint,\n  copyCheckpoint,\n  type PendingWrite,\n  type PendingWriteValue,\n  uuid5,\n  maxChannelVersion,\n  BaseStore,\n} from \"@langchain/langgraph-checkpoint\";\nimport {\n  BaseChannel,\n  createCheckpoint,\n  emptyChannels,\n  isBaseChannel,\n} from \"../channels/base.js\";\nimport { PregelNode } from \"./read.js\";\nimport { readChannel, readChannels } from \"./io.js\";\nimport {\n  _isSend,\n  _isSendInterface,\n  CONFIG_KEY_CHECKPOINT_MAP,\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  CONFIG_KEY_CHECKPOINTER,\n  CONFIG_KEY_READ,\n  CONFIG_KEY_TASK_ID,\n  CONFIG_KEY_SEND,\n  INTERRUPT,\n  RESERVED,\n  Send,\n  TAG_HIDDEN,\n  TASKS,\n  CHECKPOINT_NAMESPACE_END,\n  PUSH,\n  PULL,\n  RESUME,\n  NULL_TASK_ID,\n  CONFIG_KEY_SCRATCHPAD,\n  CONFIG_KEY_WRITES,\n} from \"../constants.js\";\nimport { PregelExecutableTask, PregelTaskDescription } from \"./types.js\";\nimport { EmptyChannelError, InvalidUpdateError } from \"../errors.js\";\nimport { getNullChannelVersion } from \"./utils/index.js\";\nimport { ManagedValueMapping } from \"../managed/base.js\";\nimport { LangGraphRunnableConfig } from \"./runnable_types.js\";\n\n/**\n * Construct a type with a set of properties K of type T\n */\nexport type StrRecord<K extends string, T> = {\n  [P in K]: T;\n};\n\nexport type WritesProtocol<C = string> = {\n  name: string;\n  writes: PendingWrite<C>[];\n  triggers: string[];\n  path?: [string, ...(string | number)[]];\n};\n\nexport const increment = (current?: number) => {\n  return current !== undefined ? current + 1 : 1;\n};\n\nexport function shouldInterrupt<N extends PropertyKey, C extends PropertyKey>(\n  checkpoint: Checkpoint,\n  interruptNodes: All | N[],\n  tasks: PregelExecutableTask<N, C>[]\n): boolean {\n  const versionValues = Object.values(checkpoint.channel_versions);\n  const versionType =\n    versionValues.length > 0 ? typeof versionValues[0] : undefined;\n  let nullVersion: number | string;\n  if (versionType === \"number\") {\n    nullVersion = 0;\n  } else if (versionType === \"string\") {\n    nullVersion = \"\";\n  }\n  const seen = checkpoint.versions_seen[INTERRUPT] ?? {};\n\n  const anyChannelUpdated = Object.entries(checkpoint.channel_versions).some(\n    ([chan, version]) => {\n      return version > (seen[chan] ?? nullVersion);\n    }\n  );\n\n  const anyTriggeredNodeInInterruptNodes = tasks.some((task) =>\n    interruptNodes === \"*\"\n      ? !task.config?.tags?.includes(TAG_HIDDEN)\n      : interruptNodes.includes(task.name)\n  );\n\n  return anyChannelUpdated && anyTriggeredNodeInInterruptNodes;\n}\n\nexport function _localRead<Cc extends Record<string, BaseChannel>>(\n  step: number,\n  checkpoint: ReadonlyCheckpoint,\n  channels: Cc,\n  managed: ManagedValueMapping,\n  task: WritesProtocol<keyof Cc>,\n  select: Array<keyof Cc> | keyof Cc,\n  fresh: boolean = false\n): Record<string, unknown> | unknown {\n  let managedKeys: Array<keyof Cc> = [];\n  let updated = new Set<keyof Cc>();\n\n  if (!Array.isArray(select)) {\n    for (const [c] of task.writes) {\n      if (c === select) {\n        updated = new Set([c]);\n        break;\n      }\n    }\n    updated = updated || new Set();\n  } else {\n    managedKeys = select.filter((k) => managed.get(k as string)) as Array<\n      keyof Cc\n    >;\n    select = select.filter((k) => !managed.get(k as string)) as Array<keyof Cc>;\n    updated = new Set(\n      select.filter((c) => task.writes.some(([key, _]) => key === c))\n    );\n  }\n\n  let values: Record<string, unknown>;\n\n  if (fresh && updated.size > 0) {\n    const localChannels = Object.fromEntries(\n      Object.entries(channels).filter(([k, _]) => updated.has(k as keyof Cc))\n    ) as Partial<Cc>;\n\n    const newCheckpoint = createCheckpoint(checkpoint, localChannels as Cc, -1);\n    const newChannels = emptyChannels(localChannels as Cc, newCheckpoint);\n\n    _applyWrites(copyCheckpoint(newCheckpoint), newChannels, [task]);\n    values = readChannels({ ...channels, ...newChannels }, select);\n  } else {\n    values = readChannels(channels, select);\n  }\n\n  if (managedKeys.length > 0) {\n    for (const k of managedKeys) {\n      const managedValue = managed.get(k as string);\n      if (managedValue) {\n        const resultOfManagedCall = managedValue.call(step);\n        values[k as string] = resultOfManagedCall;\n      }\n    }\n  }\n\n  return values;\n}\n\nexport function _localWrite(\n  step: number,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  commit: (writes: [string, any][]) => any,\n  processes: Record<string, PregelNode>,\n  managed: ManagedValueMapping,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  writes: [string, any][]\n) {\n  for (const [chan, value] of writes) {\n    if (chan === TASKS) {\n      if (!_isSend(value)) {\n        throw new InvalidUpdateError(\n          `Invalid packet type, expected SendProtocol, got ${JSON.stringify(\n            value\n          )}`\n        );\n      }\n      if (!(value.node in processes)) {\n        throw new InvalidUpdateError(\n          `Invalid node name \"${value.node}\" in Send packet`\n        );\n      }\n      // replace any runtime values with placeholders\n      managed.replaceRuntimeValues(step, value.args);\n    }\n  }\n  commit(writes);\n}\n\nconst IGNORE = new Set<string | number | symbol>([PUSH, RESUME, INTERRUPT]);\n\nexport function _applyWrites<Cc extends Record<string, BaseChannel>>(\n  checkpoint: Checkpoint,\n  channels: Cc,\n  tasks: WritesProtocol<keyof Cc>[],\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  getNextVersion?: (version: any, channel: BaseChannel) => any\n): Record<string, PendingWriteValue[]> {\n  // Sort tasks by first 3 path elements for deterministic order\n  // Later path parts (like task IDs) are ignored for sorting\n  tasks.sort((a, b) => {\n    const aPath = a.path?.slice(0, 3) || [];\n    const bPath = b.path?.slice(0, 3) || [];\n\n    // Compare each path element\n    for (let i = 0; i < Math.min(aPath.length, bPath.length); i += 1) {\n      if (aPath[i] < bPath[i]) return -1;\n      if (aPath[i] > bPath[i]) return 1;\n    }\n\n    // If one path is shorter, it comes first\n    return aPath.length - bPath.length;\n  });\n\n  // if no task has triggers this is applying writes from the null task only\n  // so we don't do anything other than update the channels written to\n  const bumpStep = tasks.some((task) => task.triggers.length > 0);\n\n  // Filter out non instances of BaseChannel\n  const onlyChannels = Object.fromEntries(\n    Object.entries(channels).filter(([_, value]) => isBaseChannel(value))\n  ) as Cc;\n  // Update seen versions\n  for (const task of tasks) {\n    if (checkpoint.versions_seen[task.name] === undefined) {\n      checkpoint.versions_seen[task.name] = {};\n    }\n    for (const chan of task.triggers) {\n      if (chan in checkpoint.channel_versions) {\n        checkpoint.versions_seen[task.name][chan] =\n          checkpoint.channel_versions[chan];\n      }\n    }\n  }\n\n  // Find the highest version of all channels\n  let maxVersion: string | number | undefined;\n  if (Object.keys(checkpoint.channel_versions).length > 0) {\n    maxVersion = maxChannelVersion(\n      ...Object.values(checkpoint.channel_versions)\n    );\n  }\n\n  // Consume all channels that were read\n  const channelsToConsume = new Set(\n    tasks\n      .flatMap((task) => task.triggers)\n      .filter((chan) => !RESERVED.includes(chan))\n  );\n\n  for (const chan of channelsToConsume) {\n    if (chan in onlyChannels && onlyChannels[chan].consume()) {\n      if (getNextVersion !== undefined) {\n        checkpoint.channel_versions[chan] = getNextVersion(\n          maxVersion,\n          onlyChannels[chan]\n        );\n      }\n    }\n  }\n\n  // Clear pending sends\n  if (checkpoint.pending_sends?.length && bumpStep) {\n    checkpoint.pending_sends = [];\n  }\n\n  // Group writes by channel\n  const pendingWriteValuesByChannel = {} as Record<\n    keyof Cc,\n    PendingWriteValue[]\n  >;\n  const pendingWritesByManaged = {} as Record<keyof Cc, PendingWriteValue[]>;\n  for (const task of tasks) {\n    for (const [chan, val] of task.writes) {\n      if (IGNORE.has(chan)) {\n        // do nothing\n      } else if (chan === TASKS) {\n        // TODO: remove branch in 1.0\n        checkpoint.pending_sends.push({\n          node: (val as Send).node,\n          args: (val as Send).args,\n        });\n      } else if (chan in onlyChannels) {\n        if (chan in pendingWriteValuesByChannel) {\n          pendingWriteValuesByChannel[chan].push(val);\n        } else {\n          pendingWriteValuesByChannel[chan] = [val];\n        }\n      } else {\n        if (chan in pendingWritesByManaged) {\n          pendingWritesByManaged[chan].push(val);\n        } else {\n          pendingWritesByManaged[chan] = [val];\n        }\n      }\n    }\n  }\n\n  // find the highest version of all channels\n  maxVersion = undefined;\n  if (Object.keys(checkpoint.channel_versions).length > 0) {\n    maxVersion = maxChannelVersion(\n      ...Object.values(checkpoint.channel_versions)\n    );\n  }\n\n  const updatedChannels: Set<string> = new Set();\n  // Apply writes to channels\n  for (const [chan, vals] of Object.entries(pendingWriteValuesByChannel)) {\n    if (chan in onlyChannels) {\n      let updated;\n      try {\n        updated = onlyChannels[chan].update(vals);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } catch (e: any) {\n        if (e.name === InvalidUpdateError.unminifiable_name) {\n          const wrappedError = new InvalidUpdateError(\n            `Invalid update for channel \"${chan}\" with values ${JSON.stringify(\n              vals\n            )}: ${e.message}`\n          );\n          wrappedError.lc_error_code = e.lc_error_code;\n          throw wrappedError;\n        } else {\n          throw e;\n        }\n      }\n      if (updated && getNextVersion !== undefined) {\n        checkpoint.channel_versions[chan] = getNextVersion(\n          maxVersion,\n          onlyChannels[chan]\n        );\n      }\n      updatedChannels.add(chan);\n    }\n  }\n\n  // Channels that weren't updated in this step are notified of a new step\n  if (bumpStep) {\n    for (const chan of Object.keys(onlyChannels)) {\n      if (!updatedChannels.has(chan)) {\n        const updated = onlyChannels[chan].update([]);\n        if (updated && getNextVersion !== undefined) {\n          checkpoint.channel_versions[chan] = getNextVersion(\n            maxVersion,\n            onlyChannels[chan]\n          );\n        }\n      }\n    }\n  }\n\n  // Return managed values writes to be applied externally\n  return pendingWritesByManaged;\n}\n\nexport type NextTaskExtraFields = {\n  step: number;\n  isResuming?: boolean;\n  checkpointer?: BaseCheckpointSaver;\n  manager?: CallbackManagerForChainRun;\n  store?: BaseStore;\n};\n\nexport type NextTaskExtraFieldsWithStore = NextTaskExtraFields & {\n  store?: BaseStore;\n};\n\nexport type NextTaskExtraFieldsWithoutStore = NextTaskExtraFields & {\n  store?: never;\n};\n\nexport function _prepareNextTasks<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: [string, string, unknown][] | undefined,\n  processes: Nn,\n  channels: Cc,\n  managed: ManagedValueMapping,\n  config: RunnableConfig,\n  forExecution: false,\n  extra: NextTaskExtraFieldsWithoutStore\n): Record<string, PregelTaskDescription>;\n\nexport function _prepareNextTasks<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: [string, string, unknown][] | undefined,\n  processes: Nn,\n  channels: Cc,\n  managed: ManagedValueMapping,\n  config: RunnableConfig,\n  forExecution: true,\n  extra: NextTaskExtraFieldsWithStore\n): Record<string, PregelExecutableTask<keyof Nn, keyof Cc>>;\n\n/**\n * Prepare the set of tasks that will make up the next Pregel step.\n * This is the union of all PUSH tasks (Sends) and PULL tasks (nodes triggered\n * by edges).\n */\nexport function _prepareNextTasks<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: [string, string, unknown][] | undefined,\n  processes: Nn,\n  channels: Cc,\n  managed: ManagedValueMapping,\n  config: RunnableConfig,\n  forExecution: boolean,\n  extra: NextTaskExtraFieldsWithStore | NextTaskExtraFieldsWithoutStore\n):\n  | Record<string, PregelTaskDescription>\n  | Record<string, PregelExecutableTask<keyof Nn, keyof Cc>> {\n  const tasks:\n    | Record<string, PregelExecutableTask<keyof Nn, keyof Cc>>\n    | Record<string, PregelTaskDescription> = {};\n  // Consume pending packets\n  for (let i = 0; i < checkpoint.pending_sends.length; i += 1) {\n    const task = _prepareSingleTask(\n      [PUSH, i],\n      checkpoint,\n      pendingWrites,\n      processes,\n      channels,\n      managed,\n      config,\n      forExecution,\n      extra\n    );\n    if (task !== undefined) {\n      tasks[task.id] = task;\n    }\n  }\n  // Check if any processes should be run in next step\n  // If so, prepare the values to be passed to them\n  for (const name of Object.keys(processes)) {\n    const task = _prepareSingleTask(\n      [PULL, name],\n      checkpoint,\n      pendingWrites,\n      processes,\n      channels,\n      managed,\n      config,\n      forExecution,\n      extra\n    );\n    if (task !== undefined) {\n      tasks[task.id] = task;\n    }\n  }\n  return tasks;\n}\n\nexport function _prepareSingleTask<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  taskPath: [string, string | number],\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: [string, string, unknown][] | undefined,\n  processes: Nn,\n  channels: Cc,\n  managed: ManagedValueMapping,\n  config: RunnableConfig,\n  forExecution: false,\n  extra: NextTaskExtraFields\n): PregelTaskDescription | undefined;\n\nexport function _prepareSingleTask<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  taskPath: [string, ...(string | number)[]],\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: [string, string, unknown][] | undefined,\n  processes: Nn,\n  channels: Cc,\n  managed: ManagedValueMapping,\n  config: RunnableConfig,\n  forExecution: true,\n  extra: NextTaskExtraFields\n): PregelExecutableTask<keyof Nn, keyof Cc> | undefined;\n\nexport function _prepareSingleTask<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  taskPath: [string, ...(string | number)[]],\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: [string, string, unknown][] | undefined,\n  processes: Nn,\n  channels: Cc,\n  managed: ManagedValueMapping,\n  config: RunnableConfig,\n  forExecution: boolean,\n  extra: NextTaskExtraFieldsWithStore\n): PregelTaskDescription | PregelExecutableTask<keyof Nn, keyof Cc> | undefined;\n\n/**\n * Prepares a single task for the next Pregel step, given a task path, which\n * uniquely identifies a PUSH or PULL task within the graph.\n */\nexport function _prepareSingleTask<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  taskPath: [string, ...(string | number)[]],\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: [string, string, unknown][] | undefined,\n  processes: Nn,\n  channels: Cc,\n  managed: ManagedValueMapping,\n  config: LangGraphRunnableConfig,\n  forExecution: boolean,\n  extra: NextTaskExtraFields\n):\n  | PregelTaskDescription\n  | PregelExecutableTask<keyof Nn, keyof Cc>\n  | undefined {\n  const { step, checkpointer, manager } = extra;\n  const configurable = config.configurable ?? {};\n  const parentNamespace = configurable.checkpoint_ns ?? \"\";\n\n  if (taskPath[0] === PUSH) {\n    const index =\n      typeof taskPath[1] === \"number\"\n        ? taskPath[1]\n        : parseInt(taskPath[1] as string, 10);\n    if (index >= checkpoint.pending_sends.length) {\n      return undefined;\n    }\n    const packet = checkpoint.pending_sends[index];\n    if (!_isSendInterface(packet)) {\n      console.warn(\n        `Ignoring invalid packet ${JSON.stringify(packet)} in pending sends.`\n      );\n      return undefined;\n    }\n    if (!(packet.node in processes)) {\n      console.warn(\n        `Ignoring unknown node name ${packet.node} in pending sends.`\n      );\n      return undefined;\n    }\n    const triggers = [PUSH];\n    const checkpointNamespace =\n      parentNamespace === \"\"\n        ? packet.node\n        : `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${packet.node}`;\n    const taskId = uuid5(\n      JSON.stringify([\n        checkpointNamespace,\n        step.toString(),\n        packet.node,\n        PUSH,\n        index.toString(),\n      ]),\n      checkpoint.id\n    );\n    const taskCheckpointNamespace = `${checkpointNamespace}${CHECKPOINT_NAMESPACE_END}${taskId}`;\n    let metadata = {\n      langgraph_step: step,\n      langgraph_node: packet.node,\n      langgraph_triggers: triggers,\n      langgraph_path: taskPath,\n      langgraph_checkpoint_ns: taskCheckpointNamespace,\n    };\n    if (forExecution) {\n      const proc = processes[packet.node];\n      const node = proc.getNode();\n      if (node !== undefined) {\n        managed.replaceRuntimePlaceholders(step, packet.args);\n        if (proc.metadata !== undefined) {\n          metadata = { ...metadata, ...proc.metadata };\n        }\n        const writes: [keyof Cc, unknown][] = [];\n        return {\n          name: packet.node,\n          input: packet.args,\n          proc: node,\n          subgraphs: proc.subgraphs,\n          writes,\n          config: patchConfig(\n            mergeConfigs(config, {\n              metadata,\n              tags: proc.tags,\n              store: extra.store ?? config.store,\n            }),\n            {\n              runName: packet.node,\n              callbacks: manager?.getChild(`graph:step:${step}`),\n              configurable: {\n                [CONFIG_KEY_TASK_ID]: taskId,\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                [CONFIG_KEY_SEND]: (writes_: [string, any][]) =>\n                  _localWrite(\n                    step,\n                    (items: [keyof Cc, unknown][]) => writes.push(...items),\n                    processes,\n                    managed,\n                    writes_\n                  ),\n                [CONFIG_KEY_READ]: (\n                  select_: Array<keyof Cc> | keyof Cc,\n                  fresh_: boolean = false\n                ) =>\n                  _localRead(\n                    step,\n                    checkpoint,\n                    channels,\n                    managed,\n                    {\n                      name: packet.node,\n                      writes: writes as Array<[string, unknown]>,\n                      triggers,\n                      path: taskPath,\n                    },\n                    select_,\n                    fresh_\n                  ),\n                [CONFIG_KEY_CHECKPOINTER]:\n                  checkpointer ?? configurable[CONFIG_KEY_CHECKPOINTER],\n                [CONFIG_KEY_CHECKPOINT_MAP]: {\n                  ...configurable[CONFIG_KEY_CHECKPOINT_MAP],\n                  [parentNamespace]: checkpoint.id,\n                },\n                [CONFIG_KEY_WRITES]: [\n                  ...(pendingWrites || []),\n                  ...(configurable[CONFIG_KEY_WRITES] || []),\n                ].filter((w) => w[0] === NULL_TASK_ID || w[0] === taskId),\n                [CONFIG_KEY_SCRATCHPAD]: {},\n                checkpoint_id: undefined,\n                checkpoint_ns: taskCheckpointNamespace,\n              },\n            }\n          ),\n          triggers,\n          retry_policy: proc.retryPolicy,\n          id: taskId,\n          path: taskPath,\n          writers: proc.getWriters(),\n        };\n      }\n    } else {\n      return { id: taskId, name: packet.node, interrupts: [], path: taskPath };\n    }\n  } else if (taskPath[0] === PULL) {\n    const name = taskPath[1].toString();\n    const proc = processes[name];\n    if (proc === undefined) {\n      return undefined;\n    }\n    const nullVersion = getNullChannelVersion(checkpoint.channel_versions);\n    if (nullVersion === undefined) {\n      return undefined;\n    }\n    const seen = checkpoint.versions_seen[name] ?? {};\n    const triggers = proc.triggers\n      .filter((chan) => {\n        const result = readChannel(channels, chan, false, true);\n        const isEmptyChannelError =\n          // eslint-disable-next-line no-instanceof/no-instanceof\n          result instanceof Error &&\n          result.name === EmptyChannelError.unminifiable_name;\n        return (\n          !isEmptyChannelError &&\n          (checkpoint.channel_versions[chan] ?? nullVersion) >\n            (seen[chan] ?? nullVersion)\n        );\n      })\n      .sort();\n    // If any of the channels read by this process were updated\n    if (triggers.length > 0) {\n      const val = _procInput(step, proc, managed, channels, forExecution);\n      if (val === undefined) {\n        return undefined;\n      }\n      const checkpointNamespace =\n        parentNamespace === \"\"\n          ? name\n          : `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${name}`;\n      const taskId = uuid5(\n        JSON.stringify([\n          checkpointNamespace,\n          step.toString(),\n          name,\n          PULL,\n          triggers,\n        ]),\n        checkpoint.id\n      );\n      const taskCheckpointNamespace = `${checkpointNamespace}${CHECKPOINT_NAMESPACE_END}${taskId}`;\n      let metadata = {\n        langgraph_step: step,\n        langgraph_node: name,\n        langgraph_triggers: triggers,\n        langgraph_path: taskPath,\n        langgraph_checkpoint_ns: taskCheckpointNamespace,\n      };\n      if (forExecution) {\n        const node = proc.getNode();\n        if (node !== undefined) {\n          if (proc.metadata !== undefined) {\n            metadata = { ...metadata, ...proc.metadata };\n          }\n          const writes: [keyof Cc, unknown][] = [];\n          const taskCheckpointNamespace = `${checkpointNamespace}${CHECKPOINT_NAMESPACE_END}${taskId}`;\n          return {\n            name,\n            input: val,\n            proc: node,\n            subgraphs: proc.subgraphs,\n            writes,\n            config: patchConfig(\n              mergeConfigs(config, {\n                metadata,\n                tags: proc.tags,\n                store: extra.store ?? config.store,\n              }),\n              {\n                runName: name,\n                callbacks: manager?.getChild(`graph:step:${step}`),\n                configurable: {\n                  [CONFIG_KEY_TASK_ID]: taskId,\n                  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                  [CONFIG_KEY_SEND]: (writes_: [string, any][]) =>\n                    _localWrite(\n                      step,\n                      (items: [keyof Cc, unknown][]) => {\n                        writes.push(...items);\n                      },\n                      processes,\n                      managed,\n                      writes_\n                    ),\n                  [CONFIG_KEY_READ]: (\n                    select_: Array<keyof Cc> | keyof Cc,\n                    fresh_: boolean = false\n                  ) =>\n                    _localRead(\n                      step,\n                      checkpoint,\n                      channels,\n                      managed,\n                      {\n                        name,\n                        writes: writes as Array<[string, unknown]>,\n                        triggers,\n                        path: taskPath,\n                      },\n                      select_,\n                      fresh_\n                    ),\n                  [CONFIG_KEY_CHECKPOINTER]:\n                    checkpointer ?? configurable[CONFIG_KEY_CHECKPOINTER],\n                  [CONFIG_KEY_CHECKPOINT_MAP]: {\n                    ...configurable[CONFIG_KEY_CHECKPOINT_MAP],\n                    [parentNamespace]: checkpoint.id,\n                  },\n                  [CONFIG_KEY_WRITES]: [\n                    ...(pendingWrites || []),\n                    ...(configurable[CONFIG_KEY_WRITES] || []),\n                  ].filter((w) => w[0] === NULL_TASK_ID || w[0] === taskId),\n                  [CONFIG_KEY_SCRATCHPAD]: {},\n                  checkpoint_id: undefined,\n                  checkpoint_ns: taskCheckpointNamespace,\n                },\n              }\n            ),\n            triggers,\n            retry_policy: proc.retryPolicy,\n            id: taskId,\n            path: taskPath,\n            writers: proc.getWriters(),\n          };\n        }\n      } else {\n        return { id: taskId, name, interrupts: [], path: taskPath };\n      }\n    }\n  }\n  return undefined;\n}\n\nfunction _procInput(\n  step: number,\n  proc: PregelNode,\n  managed: ManagedValueMapping,\n  channels: StrRecord<string, BaseChannel>,\n  forExecution: boolean\n) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let val: any;\n\n  if (typeof proc.channels === \"object\" && !Array.isArray(proc.channels)) {\n    val = {};\n    for (const [k, chan] of Object.entries(proc.channels)) {\n      if (proc.triggers.includes(chan)) {\n        try {\n          val[k] = readChannel(channels, chan, false);\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } catch (e: any) {\n          if (e.name === EmptyChannelError.unminifiable_name) {\n            return undefined;\n          } else {\n            throw e;\n          }\n        }\n      } else if (chan in channels) {\n        try {\n          val[k] = readChannel(channels, chan, true);\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } catch (e: any) {\n          if (e.name === EmptyChannelError.unminifiable_name) {\n            continue;\n          } else {\n            throw e;\n          }\n        }\n      } else {\n        val[k] = managed.get(k)?.call(step);\n      }\n    }\n  } else if (Array.isArray(proc.channels)) {\n    let successfulRead = false;\n    for (const chan of proc.channels) {\n      try {\n        val = readChannel(channels, chan, false);\n        successfulRead = true;\n        break;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } catch (e: any) {\n        if (e.name === EmptyChannelError.unminifiable_name) {\n          continue;\n        } else {\n          throw e;\n        }\n      }\n    }\n    if (!successfulRead) {\n      return undefined;\n    }\n  } else {\n    throw new Error(\n      `Invalid channels type, expected list or dict, got ${proc.channels}`\n    );\n  }\n\n  // If the process has a mapper, apply it to the value\n  if (forExecution && proc.mapper !== undefined) {\n    val = proc.mapper(val);\n  }\n\n  return val;\n}\n",
    "last_modified": "Tue, 17 Dec 2024 17:05:28 GMT"
  },
  {
    "url": "https://github.com/langchain-ai/langgraphjs/blob/main/libs/langgraph/src/pregel/debug.ts",
    "markdown": "import { RunnableConfig } from \"@langchain/core/runnables\";\nimport {\n  CheckpointMetadata,\n  CheckpointPendingWrite,\n  PendingWrite,\n} from \"@langchain/langgraph-checkpoint\";\nimport { BaseChannel } from \"../channels/base.js\";\nimport { ERROR, Interrupt, INTERRUPT, TAG_HIDDEN } from \"../constants.js\";\nimport { EmptyChannelError } from \"../errors.js\";\nimport {\n  PregelExecutableTask,\n  PregelTaskDescription,\n  StateSnapshot,\n} from \"./types.js\";\nimport { readChannels } from \"./io.js\";\nimport { findSubgraphPregel } from \"./utils/subgraph.js\";\n\ntype ConsoleColors = {\n  start: string;\n  end: string;\n};\n\ntype ConsoleColorMap = {\n  [key: string]: ConsoleColors;\n};\n\nconst COLORS_MAP: ConsoleColorMap = {\n  blue: {\n    start: \"\\x1b[34m\",\n    end: \"\\x1b[0m\",\n  },\n  green: {\n    start: \"\\x1b[32m\",\n    end: \"\\x1b[0m\",\n  },\n  yellow: {\n    start: \"\\x1b[33;1m\",\n    end: \"\\x1b[0m\",\n  },\n};\n\n/**\n * Wrap some text in a color for printing to the console.\n */\nconst wrap = (color: ConsoleColors, text: string): string =>\n  `${color.start}${text}${color.end}`;\n\nexport function printCheckpoint<Value>(\n  step: number,\n  channels: Record<string, BaseChannel<Value>>\n) {\n  console.log(\n    [\n      `${wrap(COLORS_MAP.blue, \"[langgraph/checkpoint]\")}`,\n      `Finishing step ${step}. Channel values:\\n`,\n      `\\n${JSON.stringify(\n        Object.fromEntries(_readChannels<Value>(channels)),\n        null,\n        2\n      )}`,\n    ].join(\"\")\n  );\n}\n\nfunction* _readChannels<Value>(\n  channels: Record<string, BaseChannel<Value>>\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): IterableIterator<[string, any]> {\n  for (const [name, channel] of Object.entries(channels)) {\n    try {\n      yield [name, channel.get()];\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (error: any) {\n      if (error.name === EmptyChannelError.unminifiable_name) {\n        // Skip the channel if it's empty\n        continue;\n      } else {\n        throw error; // Re-throw the error if it's not an EmptyChannelError\n      }\n    }\n  }\n}\n\nexport function* mapDebugTasks<N extends PropertyKey, C extends PropertyKey>(\n  step: number,\n  tasks: readonly PregelExecutableTask<N, C>[]\n) {\n  const ts = new Date().toISOString();\n  for (const { id, name, input, config, triggers, writes } of tasks) {\n    if (config?.tags?.includes(TAG_HIDDEN)) continue;\n\n    const interrupts = writes\n      .filter(([writeId, n]) => {\n        return writeId === id && n === INTERRUPT;\n      })\n      .map(([, v]) => {\n        return v;\n      });\n    yield {\n      type: \"task\",\n      timestamp: ts,\n      step,\n      payload: {\n        id,\n        name,\n        input,\n        triggers,\n        interrupts,\n      },\n    };\n  }\n}\n\nexport function* mapDebugTaskResults<\n  N extends PropertyKey,\n  C extends PropertyKey\n>(\n  step: number,\n  tasks: readonly [PregelExecutableTask<N, C>, PendingWrite<C>[]][],\n  streamChannels: PropertyKey | Array<PropertyKey>\n) {\n  const ts = new Date().toISOString();\n  for (const [{ id, name, config }, writes] of tasks) {\n    if (config?.tags?.includes(TAG_HIDDEN)) continue;\n    yield {\n      type: \"task_result\",\n      timestamp: ts,\n      step,\n      payload: {\n        id,\n        name,\n        result: writes.filter(([channel]) => {\n          return Array.isArray(streamChannels)\n            ? streamChannels.includes(channel)\n            : channel === streamChannels;\n        }),\n        interrupts: writes.filter((w) => w[0] === INTERRUPT).map((w) => w[1]),\n      },\n    };\n  }\n}\n\nexport function* mapDebugCheckpoint<\n  N extends PropertyKey,\n  C extends PropertyKey\n>(\n  step: number,\n  config: RunnableConfig,\n  channels: Record<string, BaseChannel>,\n  streamChannels: string | string[],\n  metadata: CheckpointMetadata,\n  tasks: readonly PregelExecutableTask<N, C>[],\n  pendingWrites: CheckpointPendingWrite[],\n  parentConfig: RunnableConfig | undefined\n) {\n  function formatConfig(config: RunnableConfig) {\n    // https://stackoverflow.com/a/78298178\n    type CamelToSnake<\n      T extends string,\n      A extends string = \"\"\n    > = T extends `${infer F}${infer R}`\n      ? CamelToSnake<\n          R,\n          `${A}${F extends Lowercase<F> ? F : `_${Lowercase<F>}`}`\n        >\n      : A;\n\n    // make sure the config is consistent with Python\n    const pyConfig: Partial<\n      Record<CamelToSnake<keyof RunnableConfig>, unknown>\n    > = {};\n\n    if (config.callbacks != null) pyConfig.callbacks = config.callbacks;\n    if (config.configurable != null)\n      pyConfig.configurable = config.configurable;\n    if (config.maxConcurrency != null)\n      pyConfig.max_concurrency = config.maxConcurrency;\n\n    if (config.metadata != null) pyConfig.metadata = config.metadata;\n    if (config.recursionLimit != null)\n      pyConfig.recursion_limit = config.recursionLimit;\n    if (config.runId != null) pyConfig.run_id = config.runId;\n    if (config.runName != null) pyConfig.run_name = config.runName;\n    if (config.tags != null) pyConfig.tags = config.tags;\n\n    return pyConfig;\n  }\n\n  const parentNs = config.configurable?.checkpoint_ns;\n  const taskStates: Record<string, RunnableConfig | StateSnapshot> = {};\n\n  for (const task of tasks) {\n    const candidates = task.subgraphs?.length ? task.subgraphs : [task.proc];\n    if (!candidates.find(findSubgraphPregel)) continue;\n\n    let taskNs = `${task.name as string}:${task.id}`;\n    if (parentNs) taskNs = `${parentNs}|${taskNs}`;\n\n    taskStates[task.id] = {\n      configurable: {\n        thread_id: config.configurable?.thread_id,\n        checkpoint_ns: taskNs,\n      },\n    };\n  }\n\n  const ts = new Date().toISOString();\n  yield {\n    type: \"checkpoint\",\n    timestamp: ts,\n    step,\n    payload: {\n      config: formatConfig(config),\n      values: readChannels(channels, streamChannels),\n      metadata,\n      next: tasks.map((task) => task.name),\n      tasks: tasksWithWrites(tasks, pendingWrites, taskStates),\n      parentConfig: parentConfig ? formatConfig(parentConfig) : undefined,\n    },\n  };\n}\n\nexport function tasksWithWrites<N extends PropertyKey, C extends PropertyKey>(\n  tasks: PregelTaskDescription[] | readonly PregelExecutableTask<N, C>[],\n  pendingWrites: CheckpointPendingWrite[],\n  states?: Record<string, RunnableConfig | StateSnapshot>\n): PregelTaskDescription[] {\n  return tasks.map((task): PregelTaskDescription => {\n    const error = pendingWrites.find(\n      ([id, n]) => id === task.id && n === ERROR\n    )?.[2];\n\n    const interrupts = pendingWrites\n      .filter(([id, n]) => {\n        return id === task.id && n === INTERRUPT;\n      })\n      .map(([, , v]) => {\n        return v;\n      }) as Interrupt[];\n    if (error) {\n      return {\n        id: task.id,\n        name: task.name as string,\n        path: task.path,\n        error,\n        interrupts,\n      };\n    }\n    return {\n      id: task.id,\n      name: task.name as string,\n      path: task.path,\n      interrupts,\n      state: states?.[task.id],\n    };\n  });\n}\n\nexport function printStepCheckpoint(\n  step: number,\n  channels: Record<string, BaseChannel<unknown>>,\n  whitelist: string[]\n): void {\n  console.log(\n    [\n      `${wrap(COLORS_MAP.blue, `[${step}:checkpoint]`)}`,\n      `\\x1b[1m State at the end of step ${step}:\\x1b[0m\\n`,\n      JSON.stringify(readChannels(channels, whitelist), null, 2),\n    ].join(\"\")\n  );\n}\n\nexport function printStepTasks<N extends PropertyKey, C extends PropertyKey>(\n  step: number,\n  nextTasks: readonly PregelExecutableTask<N, C>[]\n): void {\n  const nTasks = nextTasks.length;\n  console.log(\n    [\n      `${wrap(COLORS_MAP.blue, `[${step}:tasks]`)}`,\n      `\\x1b[1m Starting step ${step} with ${nTasks} task${\n        nTasks === 1 ? \"\" : \"s\"\n      }:\\x1b[0m\\n`,\n      nextTasks\n        .map(\n          (task) =>\n            `- ${wrap(COLORS_MAP.green, String(task.name))} -> ${JSON.stringify(\n              task.input,\n              null,\n              2\n            )}`\n        )\n        .join(\"\\n\"),\n    ].join(\"\")\n  );\n}\n\nexport function printStepWrites(\n  step: number,\n  writes: PendingWrite[],\n  whitelist: string[]\n): void {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const byChannel: Record<string, any[]> = {};\n\n  for (const [channel, value] of writes) {\n    if (whitelist.includes(channel)) {\n      if (!byChannel[channel]) {\n        byChannel[channel] = [];\n      }\n      byChannel[channel].push(value);\n    }\n  }\n\n  console.log(\n    [\n      `${wrap(COLORS_MAP.blue, `[${step}:writes]`)}`,\n      `\\x1b[1m Finished step ${step} with writes to ${\n        Object.keys(byChannel).length\n      } channel${Object.keys(byChannel).length !== 1 ? \"s\" : \"\"}:\\x1b[0m\\n`,\n      Object.entries(byChannel)\n        .map(\n          ([name, vals]) =>\n            `- ${wrap(COLORS_MAP.yellow, name)} -> ${vals\n              .map((v) => JSON.stringify(v))\n              .join(\", \")}`\n        )\n        .join(\"\\n\"),\n    ].join(\"\")\n  );\n}\n",
    "last_modified": "Tue, 17 Dec 2024 17:05:28 GMT"
  },
  {
    "url": "https://github.com/langchain-ai/langgraphjs/blob/main/libs/langgraph/src/pregel/index.ts",
    "markdown": "/* eslint-disable no-param-reassign */\nimport {\n  Runnable,\n  RunnableConfig,\n  RunnableFunc,\n  RunnableSequence,\n  getCallbackManagerForConfig,\n  mergeConfigs,\n  patchConfig,\n  _coerceToRunnable,\n  RunnableLike,\n} from \"@langchain/core/runnables\";\nimport { IterableReadableStream } from \"@langchain/core/utils/stream\";\nimport {\n  All,\n  BaseCheckpointSaver,\n  BaseStore,\n  CheckpointListOptions,\n  CheckpointTuple,\n  compareChannelVersions,\n  copyCheckpoint,\n  emptyCheckpoint,\n  PendingWrite,\n  SCHEDULED,\n  uuid5,\n} from \"@langchain/langgraph-checkpoint\";\nimport {\n  BaseChannel,\n  createCheckpoint,\n  emptyChannels,\n  isBaseChannel,\n} from \"../channels/base.js\";\nimport { PregelNode } from \"./read.js\";\nimport { validateGraph, validateKeys } from \"./validate.js\";\nimport { readChannels } from \"./io.js\";\nimport {\n  printStepCheckpoint,\n  printStepTasks,\n  printStepWrites,\n  tasksWithWrites,\n} from \"./debug.js\";\nimport { ChannelWrite, ChannelWriteEntry, PASSTHROUGH } from \"./write.js\";\nimport {\n  CONFIG_KEY_CHECKPOINTER,\n  CONFIG_KEY_READ,\n  CONFIG_KEY_SEND,\n  ERROR,\n  INTERRUPT,\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  CHECKPOINT_NAMESPACE_END,\n  CONFIG_KEY_STREAM,\n  CONFIG_KEY_TASK_ID,\n  Command,\n  NULL_TASK_ID,\n  INPUT,\n  RESUME,\n  PUSH,\n} from \"../constants.js\";\nimport {\n  PregelExecutableTask,\n  PregelInterface,\n  PregelParams,\n  StateSnapshot,\n  StreamMode,\n  PregelInputType,\n  PregelOutputType,\n  PregelOptions,\n} from \"./types.js\";\nimport {\n  GraphRecursionError,\n  GraphValueError,\n  InvalidUpdateError,\n  isGraphBubbleUp,\n  isGraphInterrupt,\n} from \"../errors.js\";\nimport {\n  _prepareNextTasks,\n  _localRead,\n  _applyWrites,\n  StrRecord,\n  WritesProtocol,\n} from \"./algo.js\";\nimport {\n  _coerceToDict,\n  getNewChannelVersions,\n  patchCheckpointMap,\n  RetryPolicy,\n} from \"./utils/index.js\";\nimport { findSubgraphPregel } from \"./utils/subgraph.js\";\nimport { PregelLoop, IterableReadableWritableStream } from \"./loop.js\";\nimport { executeTasksWithRetry } from \"./retry.js\";\nimport {\n  ChannelKeyPlaceholder,\n  isConfiguredManagedValue,\n  ManagedValue,\n  ManagedValueMapping,\n  NoopManagedValue,\n  type ManagedValueSpec,\n} from \"../managed/base.js\";\nimport { gatherIterator, patchConfigurable } from \"../utils.js\";\nimport { ensureLangGraphConfig } from \"./utils/config.js\";\nimport { LangGraphRunnableConfig } from \"./runnable_types.js\";\nimport { StreamMessagesHandler } from \"./messages.js\";\n\ntype WriteValue = Runnable | RunnableFunc<unknown, unknown> | unknown;\n\nfunction isString(value: unknown): value is string {\n  return typeof value === \"string\";\n}\n\nexport class Channel {\n  static subscribeTo(\n    channels: string,\n    options?: {\n      key?: string;\n      tags?: string[];\n    }\n  ): PregelNode;\n\n  static subscribeTo(\n    channels: string[],\n    options?: {\n      tags?: string[];\n    }\n  ): PregelNode;\n\n  static subscribeTo(\n    channels: string | string[],\n    options?: {\n      key?: string;\n      tags?: string[];\n    }\n  ): PregelNode {\n    const { key, tags } = options ?? {};\n    if (Array.isArray(channels) && key !== undefined) {\n      throw new Error(\n        \"Can't specify a key when subscribing to multiple channels\"\n      );\n    }\n\n    let channelMappingOrArray: string[] | Record<string, string>;\n\n    if (isString(channels)) {\n      if (key) {\n        channelMappingOrArray = { [key]: channels };\n      } else {\n        channelMappingOrArray = [channels];\n      }\n    } else {\n      channelMappingOrArray = Object.fromEntries(\n        channels.map((chan) => [chan, chan])\n      );\n    }\n\n    const triggers: string[] = Array.isArray(channels) ? channels : [channels];\n\n    return new PregelNode({\n      channels: channelMappingOrArray,\n      triggers,\n      tags,\n    });\n  }\n\n  static writeTo(\n    channels: string[],\n    kwargs?: Record<string, WriteValue>\n  ): ChannelWrite {\n    const channelWriteEntries: Array<ChannelWriteEntry> = [];\n\n    for (const channel of channels) {\n      channelWriteEntries.push({\n        channel,\n        value: PASSTHROUGH,\n        skipNone: false,\n      });\n    }\n\n    for (const [key, value] of Object.entries(kwargs ?? {})) {\n      if (Runnable.isRunnable(value) || typeof value === \"function\") {\n        channelWriteEntries.push({\n          channel: key,\n          value: PASSTHROUGH,\n          skipNone: true,\n          mapper: _coerceToRunnable(value as RunnableLike),\n        });\n      } else {\n        channelWriteEntries.push({\n          channel: key,\n          value,\n          skipNone: false,\n        });\n      }\n    }\n\n    return new ChannelWrite(channelWriteEntries);\n  }\n}\n\nexport type { PregelInputType, PregelOutputType, PregelOptions };\n\nexport class Pregel<\n    Nn extends StrRecord<string, PregelNode>,\n    Cc extends StrRecord<string, BaseChannel | ManagedValueSpec>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ConfigurableFieldType extends Record<string, any> = StrRecord<string, any>,\n    InputType = PregelInputType,\n    OutputType = PregelOutputType\n  >\n  extends Runnable<\n    InputType | Command | null,\n    OutputType,\n    PregelOptions<Nn, Cc, ConfigurableFieldType>\n  >\n  implements\n    PregelInterface<Nn, Cc, ConfigurableFieldType>,\n    PregelParams<Nn, Cc>\n{\n  static lc_name() {\n    return \"LangGraph\";\n  }\n\n  // Because Pregel extends `Runnable`.\n  lc_namespace = [\"langgraph\", \"pregel\"];\n\n  lg_is_pregel = true;\n\n  nodes: Nn;\n\n  channels: Cc;\n\n  inputChannels: keyof Cc | Array<keyof Cc>;\n\n  outputChannels: keyof Cc | Array<keyof Cc>;\n\n  autoValidate: boolean = true;\n\n  streamMode: StreamMode[] = [\"values\"];\n\n  streamChannels?: keyof Cc | Array<keyof Cc>;\n\n  interruptAfter?: Array<keyof Nn> | All;\n\n  interruptBefore?: Array<keyof Nn> | All;\n\n  stepTimeout?: number;\n\n  debug: boolean = false;\n\n  checkpointer?: BaseCheckpointSaver | false;\n\n  retryPolicy?: RetryPolicy;\n\n  config?: LangGraphRunnableConfig;\n\n  store?: BaseStore;\n\n  constructor(fields: PregelParams<Nn, Cc>) {\n    super(fields);\n\n    let { streamMode } = fields;\n    if (streamMode != null && !Array.isArray(streamMode)) {\n      streamMode = [streamMode];\n    }\n\n    this.nodes = fields.nodes;\n    this.channels = fields.channels;\n    this.autoValidate = fields.autoValidate ?? this.autoValidate;\n    this.streamMode = streamMode ?? this.streamMode;\n    this.inputChannels = fields.inputChannels;\n    this.outputChannels = fields.outputChannels;\n    this.streamChannels = fields.streamChannels ?? this.streamChannels;\n    this.interruptAfter = fields.interruptAfter;\n    this.interruptBefore = fields.interruptBefore;\n    this.stepTimeout = fields.stepTimeout ?? this.stepTimeout;\n    this.debug = fields.debug ?? this.debug;\n    this.checkpointer = fields.checkpointer;\n    this.retryPolicy = fields.retryPolicy;\n    this.config = fields.config;\n    this.store = fields.store;\n\n    if (this.autoValidate) {\n      this.validate();\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore Remove ignore when we remove support for 0.2 versions of core\n  override withConfig(config: RunnableConfig): typeof this {\n    const mergedConfig = mergeConfigs(this.config, config);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return new (this.constructor as any)({ ...this, config: mergedConfig });\n  }\n\n  validate(): this {\n    validateGraph<Nn, Cc>({\n      nodes: this.nodes,\n      channels: this.channels,\n      outputChannels: this.outputChannels,\n      inputChannels: this.inputChannels,\n      streamChannels: this.streamChannels,\n      interruptAfterNodes: this.interruptAfter,\n      interruptBeforeNodes: this.interruptBefore,\n    });\n\n    return this;\n  }\n\n  get streamChannelsList(): Array<keyof Cc> {\n    if (Array.isArray(this.streamChannels)) {\n      return this.streamChannels;\n    } else if (this.streamChannels) {\n      return [this.streamChannels];\n    } else {\n      return Object.keys(this.channels);\n    }\n  }\n\n  get streamChannelsAsIs(): keyof Cc | Array<keyof Cc> {\n    if (this.streamChannels) {\n      return this.streamChannels;\n    } else {\n      return Object.keys(this.channels);\n    }\n  }\n\n  async getGraphAsync(config: RunnableConfig) {\n    return this.getGraph(config);\n  }\n\n  /** @deprecated Use getSubgraphsAsync instead. The async method will become the default in the next minor release. */\n  *getSubgraphs(\n    namespace?: string,\n    recurse?: boolean\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Generator<[string, Pregel<any, any>]> {\n    for (const [name, node] of Object.entries(this.nodes)) {\n      // filter by prefix\n      if (namespace !== undefined) {\n        if (!namespace.startsWith(name)) {\n          continue;\n        }\n      }\n      // find the subgraph if any\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      type SubgraphPregelType = Pregel<any, any> | undefined;\n\n      const candidates = node.subgraphs?.length ? node.subgraphs : [node.bound];\n\n      for (const candidate of candidates) {\n        const graph = findSubgraphPregel(candidate) as SubgraphPregelType;\n\n        if (graph !== undefined) {\n          if (name === namespace) {\n            yield [name, graph];\n            return;\n          }\n\n          if (namespace === undefined) {\n            yield [name, graph];\n          }\n\n          if (recurse) {\n            let newNamespace = namespace;\n            if (namespace !== undefined) {\n              newNamespace = namespace.slice(name.length + 1);\n            }\n            for (const [subgraphName, subgraph] of graph.getSubgraphs(\n              newNamespace,\n              recurse\n            )) {\n              yield [\n                `${name}${CHECKPOINT_NAMESPACE_SEPARATOR}${subgraphName}`,\n                subgraph,\n              ];\n            }\n          }\n        }\n      }\n    }\n  }\n\n  async *getSubgraphsAsync(\n    namespace?: string,\n    recurse?: boolean\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): AsyncGenerator<[string, Pregel<any, any>]> {\n    yield* this.getSubgraphs(namespace, recurse);\n  }\n\n  protected async _prepareStateSnapshot({\n    config,\n    saved,\n    subgraphCheckpointer,\n  }: {\n    config: RunnableConfig;\n    saved?: CheckpointTuple;\n    subgraphCheckpointer?: BaseCheckpointSaver;\n  }): Promise<StateSnapshot> {\n    if (saved === undefined) {\n      return {\n        values: {},\n        next: [],\n        config,\n        tasks: [],\n      };\n    }\n    // Pass `skipManaged: true` as managed values should not be returned in get state calls.\n    const { managed } = await this.prepareSpecs(config, { skipManaged: true });\n\n    const channels = emptyChannels(\n      this.channels as Record<string, BaseChannel>,\n      saved.checkpoint\n    );\n\n    const nextTasks = Object.values(\n      _prepareNextTasks(\n        saved.checkpoint,\n        saved.pendingWrites,\n        this.nodes,\n        channels,\n        managed,\n        saved.config,\n        false,\n        { step: (saved.metadata?.step ?? -1) + 1 }\n      )\n    );\n    const subgraphs = await gatherIterator(this.getSubgraphsAsync());\n    const parentNamespace = saved.config.configurable?.checkpoint_ns ?? \"\";\n    const taskStates: Record<string, RunnableConfig | StateSnapshot> = {};\n    for (const task of nextTasks) {\n      const matchingSubgraph = subgraphs.find(([name]) => name === task.name);\n      if (!matchingSubgraph) {\n        continue;\n      }\n      // assemble checkpoint_ns for this task\n      let taskNs = `${task.name}${CHECKPOINT_NAMESPACE_END}${task.id}`;\n      if (parentNamespace) {\n        taskNs = `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${taskNs}`;\n      }\n      if (subgraphCheckpointer === undefined) {\n        // set config as signal that subgraph checkpoints exist\n        const config: RunnableConfig = {\n          configurable: {\n            thread_id: saved.config.configurable?.thread_id,\n            checkpoint_ns: taskNs,\n          },\n        };\n        taskStates[task.id] = config;\n      } else {\n        // get the state of the subgraph\n        const config: RunnableConfig = {\n          configurable: {\n            [CONFIG_KEY_CHECKPOINTER]: subgraphCheckpointer,\n            thread_id: saved.config.configurable?.thread_id,\n            checkpoint_ns: taskNs,\n          },\n        };\n        taskStates[task.id] = await matchingSubgraph[1].getState(config, {\n          subgraphs: true,\n        });\n      }\n    }\n    // apply pending writes\n    const nullWrites = (saved.pendingWrites ?? [])\n      .filter((w) => w[0] === NULL_TASK_ID)\n      .map((w) => w.slice(1)) as PendingWrite<string>[];\n    if (nullWrites.length > 0) {\n      _applyWrites(saved.checkpoint, channels, [\n        {\n          name: INPUT,\n          writes: nullWrites,\n          triggers: [],\n        },\n      ]);\n    }\n    // assemble the state snapshot\n    return {\n      values: readChannels(\n        channels,\n        this.streamChannelsAsIs as string | string[]\n      ),\n      next: nextTasks.map((task) => task.name),\n      tasks: tasksWithWrites(nextTasks, saved?.pendingWrites ?? [], taskStates),\n      metadata: saved.metadata,\n      config: patchCheckpointMap(saved.config, saved.metadata),\n      createdAt: saved.checkpoint.ts,\n      parentConfig: saved.parentConfig,\n    };\n  }\n\n  /**\n   * Get the current state of the graph.\n   */\n  async getState(\n    config: RunnableConfig,\n    options?: { subgraphs?: boolean }\n  ): Promise<StateSnapshot> {\n    const checkpointer =\n      config.configurable?.[CONFIG_KEY_CHECKPOINTER] ?? this.checkpointer;\n    if (!checkpointer) {\n      throw new GraphValueError(\"No checkpointer set\");\n    }\n\n    const checkpointNamespace: string =\n      config.configurable?.checkpoint_ns ?? \"\";\n    if (\n      checkpointNamespace !== \"\" &&\n      config.configurable?.[CONFIG_KEY_CHECKPOINTER] === undefined\n    ) {\n      // remove task_ids from checkpoint_ns\n      const recastCheckpointNamespace = checkpointNamespace\n        .split(CHECKPOINT_NAMESPACE_SEPARATOR)\n        .map((part) => part.split(CHECKPOINT_NAMESPACE_END)[0])\n        .join(CHECKPOINT_NAMESPACE_SEPARATOR);\n      for await (const [name, subgraph] of this.getSubgraphsAsync(\n        recastCheckpointNamespace,\n        true\n      )) {\n        if (name === recastCheckpointNamespace) {\n          return await subgraph.getState(\n            patchConfigurable(config, {\n              [CONFIG_KEY_CHECKPOINTER]: checkpointer,\n            }),\n            { subgraphs: options?.subgraphs }\n          );\n        }\n      }\n      throw new Error(\n        `Subgraph with namespace \"${recastCheckpointNamespace}\" not found.`\n      );\n    }\n\n    const mergedConfig = mergeConfigs(this.config, config);\n    const saved = await checkpointer.getTuple(config);\n    const snapshot = await this._prepareStateSnapshot({\n      config: mergedConfig,\n      saved,\n      subgraphCheckpointer: options?.subgraphs ? checkpointer : undefined,\n    });\n    return snapshot;\n  }\n\n  /**\n   * Get the history of the state of the graph.\n   */\n  async *getStateHistory(\n    config: RunnableConfig,\n    options?: CheckpointListOptions\n  ): AsyncIterableIterator<StateSnapshot> {\n    const checkpointer: BaseCheckpointSaver =\n      config.configurable?.[CONFIG_KEY_CHECKPOINTER] ?? this.checkpointer;\n    if (!checkpointer) {\n      throw new Error(\"No checkpointer set\");\n    }\n\n    const checkpointNamespace: string =\n      config.configurable?.checkpoint_ns ?? \"\";\n    if (\n      checkpointNamespace !== \"\" &&\n      config.configurable?.[CONFIG_KEY_CHECKPOINTER] === undefined\n    ) {\n      const recastCheckpointNamespace = checkpointNamespace\n        .split(CHECKPOINT_NAMESPACE_SEPARATOR)\n        .map((part) => part.split(CHECKPOINT_NAMESPACE_END)[0])\n        .join(CHECKPOINT_NAMESPACE_SEPARATOR);\n\n      // find the subgraph with the matching name\n      for await (const [name, pregel] of this.getSubgraphsAsync(\n        recastCheckpointNamespace,\n        true\n      )) {\n        if (name === recastCheckpointNamespace) {\n          yield* pregel.getStateHistory(\n            patchConfigurable(config, {\n              [CONFIG_KEY_CHECKPOINTER]: checkpointer,\n            }),\n            options\n          );\n          return;\n        }\n      }\n      throw new Error(\n        `Subgraph with namespace \"${recastCheckpointNamespace}\" not found.`\n      );\n    }\n\n    const mergedConfig = mergeConfigs(this.config, config, {\n      configurable: { checkpoint_ns: checkpointNamespace },\n    });\n\n    for await (const checkpointTuple of checkpointer.list(\n      mergedConfig,\n      options\n    )) {\n      yield this._prepareStateSnapshot({\n        config: checkpointTuple.config,\n        saved: checkpointTuple,\n      });\n    }\n  }\n\n  /**\n   * Update the state of the graph with the given values, as if they came from\n   * node `as_node`. If `as_node` is not provided, it will be set to the last node\n   * that updated the state, if not ambiguous.\n   */\n  async updateState(\n    inputConfig: LangGraphRunnableConfig,\n    values: Record<string, unknown> | unknown,\n    asNode?: keyof Nn | string\n  ): Promise<RunnableConfig> {\n    const checkpointer: BaseCheckpointSaver | undefined =\n      inputConfig.configurable?.[CONFIG_KEY_CHECKPOINTER] ?? this.checkpointer;\n    if (!checkpointer) {\n      throw new GraphValueError(\"No checkpointer set\");\n    }\n    // delegate to subgraph\n    const checkpointNamespace: string =\n      inputConfig.configurable?.checkpoint_ns ?? \"\";\n    if (\n      checkpointNamespace !== \"\" &&\n      inputConfig.configurable?.[CONFIG_KEY_CHECKPOINTER] === undefined\n    ) {\n      // remove task_ids from checkpoint_ns\n      const recastCheckpointNamespace = checkpointNamespace\n        .split(CHECKPOINT_NAMESPACE_SEPARATOR)\n        .map((part) => {\n          return part.split(CHECKPOINT_NAMESPACE_END)[0];\n        })\n        .join(CHECKPOINT_NAMESPACE_SEPARATOR);\n      // find the subgraph with the matching name\n      // eslint-disable-next-line no-unreachable-loop\n      for await (const [, pregel] of this.getSubgraphsAsync(\n        recastCheckpointNamespace,\n        true\n      )) {\n        return await pregel.updateState(\n          patchConfigurable(inputConfig, {\n            [CONFIG_KEY_CHECKPOINTER]: checkpointer,\n          }),\n          values,\n          asNode\n        );\n      }\n      throw new Error(`Subgraph \"${recastCheckpointNamespace}\" not found`);\n    }\n    // get last checkpoint\n    const config = this.config\n      ? mergeConfigs(this.config, inputConfig)\n      : inputConfig;\n    const saved = await checkpointer.getTuple(config);\n    const checkpoint =\n      saved !== undefined\n        ? copyCheckpoint(saved.checkpoint)\n        : emptyCheckpoint();\n    const checkpointPreviousVersions = {\n      ...saved?.checkpoint.channel_versions,\n    };\n    const step = saved?.metadata?.step ?? -1;\n    // merge configurable fields with previous checkpoint config\n    let checkpointConfig = patchConfigurable(config, {\n      checkpoint_ns: config.configurable?.checkpoint_ns ?? \"\",\n    });\n    let checkpointMetadata = config.metadata ?? {};\n    if (saved?.config.configurable) {\n      checkpointConfig = patchConfigurable(config, saved.config.configurable);\n      checkpointMetadata = {\n        ...saved.metadata,\n        ...checkpointMetadata,\n      };\n    }\n\n    // Find last node that updated the state, if not provided\n    if (values == null && asNode === undefined) {\n      const nextConfig = await checkpointer.put(\n        checkpointConfig,\n        createCheckpoint(checkpoint, undefined, step),\n        {\n          source: \"update\",\n          step: step + 1,\n          writes: {},\n          parents: saved?.metadata?.parents ?? {},\n        },\n        {}\n      );\n      return patchCheckpointMap(nextConfig, saved ? saved.metadata : undefined);\n    }\n\n    // update channels\n    const channels = emptyChannels(\n      this.channels as Record<string, BaseChannel>,\n      checkpoint\n    );\n\n    // Pass `skipManaged: true` as managed values are not used/relevant in update state calls.\n    const { managed } = await this.prepareSpecs(config, { skipManaged: true });\n\n    if (values === null && asNode === \"__end__\") {\n      if (saved) {\n        // tasks for this checkpoint\n        const nextTasks = _prepareNextTasks(\n          checkpoint,\n          saved.pendingWrites || [],\n          this.nodes,\n          channels,\n          managed,\n          saved.config,\n          true,\n          {\n            step: (saved.metadata?.step ?? -1) + 1,\n            checkpointer: this.checkpointer || undefined,\n            store: this.store,\n          }\n        );\n\n        // apply null writes\n        const nullWrites = (saved.pendingWrites || [])\n          .filter((w) => w[0] === NULL_TASK_ID)\n          .map((w) => w.slice(1)) as PendingWrite<string>[];\n        if (nullWrites.length > 0) {\n          _applyWrites(saved.checkpoint, channels, [\n            {\n              name: INPUT,\n              writes: nullWrites,\n              triggers: [],\n            },\n          ]);\n        }\n        // apply writes from tasks that already ran\n        for (const [taskId, k, v] of saved.pendingWrites || []) {\n          if ([ERROR, INTERRUPT, SCHEDULED].includes(k)) {\n            continue;\n          }\n          if (!(taskId in nextTasks)) {\n            continue;\n          }\n          nextTasks[taskId].writes.push([k, v]);\n        }\n        // clear all current tasks\n        _applyWrites(\n          checkpoint,\n          channels,\n          Object.values(nextTasks) as WritesProtocol<string>[]\n        );\n      }\n      // save checkpoint\n      const nextConfig = await checkpointer.put(\n        checkpointConfig,\n        createCheckpoint(checkpoint, undefined, step),\n        {\n          ...checkpointMetadata,\n          source: \"update\",\n          step: step + 1,\n          writes: {},\n          parents: saved?.metadata?.parents ?? {},\n        },\n        {}\n      );\n      return patchCheckpointMap(nextConfig, saved ? saved.metadata : undefined);\n    }\n    if (values == null && asNode === \"__copy__\") {\n      const nextConfig = await checkpointer.put(\n        saved?.parentConfig ?? checkpointConfig,\n        createCheckpoint(checkpoint, undefined, step),\n        {\n          source: \"fork\",\n          step: step + 1,\n          writes: {},\n          parents: saved?.metadata?.parents ?? {},\n        },\n        {}\n      );\n      return patchCheckpointMap(nextConfig, saved ? saved.metadata : undefined);\n    }\n    // apply pending writes, if not on specific checkpoint\n    if (\n      config.configurable?.checkpoint_id === undefined &&\n      saved?.pendingWrites !== undefined &&\n      saved.pendingWrites.length > 0\n    ) {\n      // tasks for this checkpoint\n      const nextTasks = _prepareNextTasks(\n        checkpoint,\n        saved.pendingWrites,\n        this.nodes,\n        channels,\n        managed,\n        saved.config,\n        true,\n        {\n          store: this.store,\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          checkpointer: this.checkpointer as any,\n          step: (saved.metadata?.step ?? -1) + 1,\n        }\n      );\n      // apply null writes\n      const nullWrites = (saved.pendingWrites ?? [])\n        .filter((w) => w[0] === NULL_TASK_ID)\n        .map((w) => w.slice(1)) as PendingWrite<string>[];\n      if (nullWrites.length > 0) {\n        _applyWrites(saved.checkpoint, channels, [\n          {\n            name: INPUT,\n            writes: nullWrites,\n            triggers: [],\n          },\n        ]);\n      }\n      // apply writes\n      for (const [tid, k, v] of saved.pendingWrites) {\n        if (\n          [ERROR, INTERRUPT, SCHEDULED].includes(k) ||\n          nextTasks[tid] === undefined\n        ) {\n          continue;\n        }\n        nextTasks[tid].writes.push([k, v]);\n      }\n      const tasks = Object.values(nextTasks).filter((task) => {\n        return task.writes.length > 0;\n      });\n      if (tasks.length > 0) {\n        _applyWrites(checkpoint, channels, tasks as WritesProtocol[]);\n      }\n    }\n    const nonNullVersion = Object.values(checkpoint.versions_seen)\n      .map((seenVersions) => {\n        return Object.values(seenVersions);\n      })\n      .flat()\n      .find((v) => !!v);\n    if (asNode === undefined && nonNullVersion === undefined) {\n      if (\n        typeof this.inputChannels === \"string\" &&\n        this.nodes[this.inputChannels] !== undefined\n      ) {\n        asNode = this.inputChannels;\n      }\n    } else if (asNode === undefined) {\n      const lastSeenByNode = Object.entries(checkpoint.versions_seen)\n        .map(([n, seen]) => {\n          return Object.values(seen).map((v) => {\n            return [v, n] as const;\n          });\n        })\n        .flat()\n        .sort(([aNumber], [bNumber]) =>\n          compareChannelVersions(aNumber, bNumber)\n        );\n      // if two nodes updated the state at the same time, it's ambiguous\n      if (lastSeenByNode) {\n        if (lastSeenByNode.length === 1) {\n          // eslint-disable-next-line prefer-destructuring\n          asNode = lastSeenByNode[0][1];\n        } else if (\n          lastSeenByNode[lastSeenByNode.length - 1][0] !==\n          lastSeenByNode[lastSeenByNode.length - 2][0]\n        ) {\n          // eslint-disable-next-line prefer-destructuring\n          asNode = lastSeenByNode[lastSeenByNode.length - 1][1];\n        }\n      }\n    }\n\n    if (asNode === undefined) {\n      throw new InvalidUpdateError(`Ambiguous update, specify \"asNode\"`);\n    }\n    if (this.nodes[asNode] === undefined) {\n      throw new InvalidUpdateError(\n        `Node \"${asNode.toString()}\" does not exist`\n      );\n    }\n\n    // run all writers of the chosen node\n    const writers = this.nodes[asNode].getWriters();\n    if (!writers.length) {\n      throw new InvalidUpdateError(\n        `No writers found for node \"${asNode.toString()}\"`\n      );\n    }\n    const task: PregelExecutableTask<keyof Nn, keyof Cc> = {\n      name: asNode,\n      input: values,\n      proc:\n        writers.length > 1\n          ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            RunnableSequence.from(writers as any, { omitSequenceTags: true })\n          : writers[0],\n      writes: [],\n      triggers: [INTERRUPT],\n      id: uuid5(INTERRUPT, checkpoint.id),\n      writers: [],\n    };\n\n    // execute task\n    await task.proc.invoke(\n      task.input,\n      patchConfig<LangGraphRunnableConfig>(\n        {\n          ...config,\n          store: config?.store ?? this.store,\n        },\n        {\n          runName: config.runName ?? `${this.getName()}UpdateState`,\n          configurable: {\n            [CONFIG_KEY_SEND]: (items: [keyof Cc, unknown][]) =>\n              task.writes.push(...items),\n            [CONFIG_KEY_READ]: (\n              select_: Array<keyof Cc> | keyof Cc,\n              fresh_: boolean = false\n            ) =>\n              _localRead(\n                step,\n                checkpoint,\n                channels,\n                managed,\n                // TODO: Why does keyof StrRecord allow number and symbol?\n                task as PregelExecutableTask<string, string>,\n                select_ as string | string[],\n                fresh_\n              ),\n          },\n        }\n      )\n    );\n\n    // save task writes\n    // channel writes are saved to current checkpoint\n    // push writes are saved to next checkpoint\n    const [channelWrites, pushWrites] = [\n      task.writes.filter((w) => w[0] !== PUSH),\n      task.writes.filter((w) => w[0] === PUSH),\n    ];\n    // save task writes\n    if (saved !== undefined && channelWrites.length > 0) {\n      await checkpointer.putWrites(\n        checkpointConfig,\n        channelWrites as PendingWrite[],\n        task.id\n      );\n    }\n\n    // apply to checkpoint\n    // TODO: Why does keyof StrRecord allow number and symbol?\n    _applyWrites(\n      checkpoint,\n      channels,\n      [task as PregelExecutableTask<string, string>],\n      checkpointer.getNextVersion.bind(this.checkpointer)\n    );\n\n    const newVersions = getNewChannelVersions(\n      checkpointPreviousVersions,\n      checkpoint.channel_versions\n    );\n    const nextConfig = await checkpointer.put(\n      checkpointConfig,\n      createCheckpoint(checkpoint, channels, step + 1),\n      {\n        source: \"update\",\n        step: step + 1,\n        writes: { [asNode]: values },\n        parents: saved?.metadata?.parents ?? {},\n      },\n      newVersions\n    );\n\n    if (pushWrites.length > 0) {\n      await checkpointer.putWrites(\n        nextConfig,\n        pushWrites as PendingWrite[],\n        task.id\n      );\n    }\n\n    return patchCheckpointMap(nextConfig, saved ? saved.metadata : undefined);\n  }\n\n  _defaults(config: PregelOptions<Nn, Cc>): [\n    boolean, // debug\n    StreamMode[], // stream mode\n    string | string[], // input keys\n    string | string[], // output keys\n    LangGraphRunnableConfig, // config without pregel keys\n    All | string[], // interrupt before\n    All | string[], // interrupt after\n    BaseCheckpointSaver | undefined,\n    BaseStore | undefined,\n    boolean\n  ] {\n    const {\n      debug,\n      streamMode,\n      inputKeys,\n      outputKeys,\n      interruptAfter,\n      interruptBefore,\n      ...rest\n    } = config;\n    let streamModeSingle = true;\n    const defaultDebug = debug !== undefined ? debug : this.debug;\n\n    let defaultOutputKeys = outputKeys;\n    if (defaultOutputKeys === undefined) {\n      defaultOutputKeys = this.streamChannelsAsIs;\n    } else {\n      validateKeys(defaultOutputKeys, this.channels);\n    }\n\n    let defaultInputKeys = inputKeys;\n    if (defaultInputKeys === undefined) {\n      defaultInputKeys = this.inputChannels;\n    } else {\n      validateKeys(defaultInputKeys, this.channels);\n    }\n\n    const defaultInterruptBefore =\n      interruptBefore ?? this.interruptBefore ?? [];\n\n    const defaultInterruptAfter = interruptAfter ?? this.interruptAfter ?? [];\n\n    let defaultStreamMode: StreamMode[];\n    if (streamMode !== undefined) {\n      defaultStreamMode = Array.isArray(streamMode) ? streamMode : [streamMode];\n      streamModeSingle = typeof streamMode === \"string\";\n    } else {\n      defaultStreamMode = this.streamMode;\n      streamModeSingle = true;\n    }\n\n    // if being called as a node in another graph, always use values mode\n    if (config.configurable?.[CONFIG_KEY_TASK_ID] !== undefined) {\n      defaultStreamMode = [\"values\"];\n    }\n\n    let defaultCheckpointer: BaseCheckpointSaver | undefined;\n    if (this.checkpointer === false) {\n      defaultCheckpointer = undefined;\n    } else if (\n      config !== undefined &&\n      config.configurable?.[CONFIG_KEY_CHECKPOINTER] !== undefined\n    ) {\n      defaultCheckpointer = config.configurable[CONFIG_KEY_CHECKPOINTER];\n    } else {\n      defaultCheckpointer = this.checkpointer;\n    }\n    const defaultStore: BaseStore | undefined = config.store ?? this.store;\n\n    return [\n      defaultDebug,\n      defaultStreamMode,\n      defaultInputKeys as string | string[],\n      defaultOutputKeys as string | string[],\n      rest,\n      defaultInterruptBefore as All | string[],\n      defaultInterruptAfter as All | string[],\n      defaultCheckpointer,\n      defaultStore,\n      streamModeSingle,\n    ];\n  }\n\n  /**\n   * Stream graph steps for a single input.\n   * @param input The input to the graph.\n   * @param options The configuration to use for the run.\n   * @param options.streamMode The mode to stream output. Defaults to value set on initialization.\n   *   Options are \"values\", \"updates\", and \"debug\". Default is \"values\".\n   *     values: Emit the current values of the state for each step.\n   *     updates: Emit only the updates to the state for each step.\n   *         Output is a dict with the node name as key and the updated values as value.\n   *     debug: Emit debug events for each step.\n   * @param options.outputKeys The keys to stream. Defaults to all non-context channels.\n   * @param options.interruptBefore Nodes to interrupt before.\n   * @param options.interruptAfter Nodes to interrupt after.\n   * @param options.debug Whether to print debug information during execution.\n   */\n  override async stream(\n    input: InputType | Command | null,\n    options?: Partial<PregelOptions<Nn, Cc, ConfigurableFieldType>>\n  ): Promise<IterableReadableStream<PregelOutputType>> {\n    // The ensureConfig method called internally defaults recursionLimit to 25 if not\n    // passed directly in `options`.\n    // There is currently no way in _streamIterator to determine whether this was\n    // set by by ensureConfig or manually by the user, so we specify the bound value here\n    // and override if it is passed as an explicit param in `options`.\n    const config = {\n      recursionLimit: this.config?.recursionLimit,\n      ...options,\n    };\n    return super.stream(input, config);\n  }\n\n  protected async prepareSpecs(\n    config: RunnableConfig,\n    options?: {\n      // Equivalent to the `skip_context` option in Python, but renamed\n      // to `managed` since JS does not implement the `Context` class.\n      skipManaged?: boolean;\n    }\n  ) {\n    const configForManaged: LangGraphRunnableConfig = {\n      ...config,\n      store: this.store,\n    };\n    const channelSpecs: Record<string, BaseChannel> = {};\n    const managedSpecs: Record<string, ManagedValueSpec> = {};\n\n    for (const [name, spec] of Object.entries(this.channels)) {\n      if (isBaseChannel(spec)) {\n        channelSpecs[name] = spec;\n      } else if (options?.skipManaged) {\n        managedSpecs[name] = {\n          cls: NoopManagedValue,\n          params: { config: {} },\n        };\n      } else {\n        managedSpecs[name] = spec;\n      }\n    }\n    const managed = new ManagedValueMapping(\n      await Object.entries(managedSpecs).reduce(\n        async (accPromise, [key, value]) => {\n          const acc = await accPromise;\n          let initializedValue;\n\n          if (isConfiguredManagedValue(value)) {\n            if (\n              \"key\" in value.params &&\n              value.params.key === ChannelKeyPlaceholder\n            ) {\n              value.params.key = key;\n            }\n            initializedValue = await value.cls.initialize(\n              configForManaged,\n              value.params\n            );\n          } else {\n            initializedValue = await value.initialize(configForManaged);\n          }\n\n          if (initializedValue !== undefined) {\n            acc.push([key, initializedValue]);\n          }\n\n          return acc;\n        },\n        Promise.resolve([] as [string, ManagedValue][])\n      )\n    );\n    return {\n      channelSpecs,\n      managed,\n    };\n  }\n\n  override async *_streamIterator(\n    input: PregelInputType | Command,\n    options?: Partial<PregelOptions<Nn, Cc>>\n  ): AsyncGenerator<PregelOutputType> {\n    const streamSubgraphs = options?.subgraphs;\n    const inputConfig = ensureLangGraphConfig(this.config, options);\n    if (\n      inputConfig.recursionLimit === undefined ||\n      inputConfig.recursionLimit < 1\n    ) {\n      throw new Error(`Passed \"recursionLimit\" must be at least 1.`);\n    }\n    if (\n      this.checkpointer !== undefined &&\n      this.checkpointer !== false &&\n      inputConfig.configurable === undefined\n    ) {\n      throw new Error(\n        `Checkpointer requires one or more of the following \"configurable\" keys: \"thread_id\", \"checkpoint_ns\", \"checkpoint_id\"`\n      );\n    }\n\n    const { runId, ...restConfig } = inputConfig;\n    // assign defaults\n    const [\n      debug,\n      streamMode,\n      ,\n      outputKeys,\n      config,\n      interruptBefore,\n      interruptAfter,\n      checkpointer,\n      store,\n      streamModeSingle,\n    ] = this._defaults(restConfig);\n\n    const stream = new IterableReadableWritableStream({\n      modes: new Set(streamMode),\n    });\n\n    // set up messages stream mode\n    if (streamMode.includes(\"messages\")) {\n      const messageStreamer = new StreamMessagesHandler((chunk) =>\n        stream.push(chunk)\n      );\n      const { callbacks } = config;\n      if (callbacks === undefined) {\n        config.callbacks = [messageStreamer];\n      } else if (Array.isArray(callbacks)) {\n        config.callbacks = callbacks.concat(messageStreamer);\n      } else {\n        const copiedCallbacks = callbacks.copy();\n        copiedCallbacks.addHandler(messageStreamer, true);\n        config.callbacks = copiedCallbacks;\n      }\n    }\n\n    // setup custom stream mode\n    if (streamMode.includes(\"custom\")) {\n      config.writer = (chunk: unknown) => stream.push([[], \"custom\", chunk]);\n    }\n\n    const callbackManager = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager?.handleChainStart(\n      this.toJSON(),\n      _coerceToDict(input, \"input\"),\n      runId,\n      undefined,\n      undefined,\n      undefined,\n      config?.runName ?? this.getName()\n    );\n\n    const { channelSpecs, managed } = await this.prepareSpecs(config);\n\n    let loop: PregelLoop | undefined;\n    let loopError: unknown;\n\n    const runLoop = async () => {\n      try {\n        loop = await PregelLoop.initialize({\n          input,\n          config,\n          checkpointer,\n          nodes: this.nodes,\n          channelSpecs,\n          managed,\n          outputKeys,\n          streamKeys: this.streamChannelsAsIs as string | string[],\n          store,\n          stream,\n        });\n        if (options?.subgraphs) {\n          loop.config.configurable = {\n            ...loop.config.configurable,\n            [CONFIG_KEY_STREAM]: loop.stream,\n          };\n        }\n        while (\n          await loop.tick({\n            inputKeys: this.inputChannels as string | string[],\n            interruptAfter,\n            interruptBefore,\n            manager: runManager,\n          })\n        ) {\n          if (debug) {\n            printStepCheckpoint(\n              loop.checkpointMetadata.step,\n              loop.channels,\n              this.streamChannelsList as string[]\n            );\n          }\n          if (debug) {\n            printStepTasks(loop.step, Object.values(loop.tasks));\n          }\n          // execute tasks, and wait for one to fail or all to finish.\n          // each task is independent from all other concurrent tasks\n          // yield updates/debug output as each task finishes\n          const taskStream = executeTasksWithRetry(\n            Object.values(loop.tasks).filter(\n              (task) => task.writes.length === 0\n            ),\n            {\n              stepTimeout: this.stepTimeout,\n              signal: config.signal,\n              retryPolicy: this.retryPolicy,\n            }\n          );\n          // Timeouts will be thrown\n          for await (const { task, error } of taskStream) {\n            if (error !== undefined) {\n              if (isGraphBubbleUp(error)) {\n                if (loop.isNested) {\n                  throw error;\n                }\n                if (isGraphInterrupt(error) && error.interrupts.length) {\n                  const interrupts: PendingWrite<string>[] =\n                    error.interrupts.map((interrupt) => [INTERRUPT, interrupt]);\n                  const resumes = task.writes.filter((w) => w[0] === RESUME);\n                  if (resumes.length) {\n                    interrupts.push(...resumes);\n                  }\n                  loop.putWrites(task.id, interrupts);\n                }\n              } else {\n                loop.putWrites(task.id, [\n                  [ERROR, { message: error.message, name: error.name }],\n                ]);\n                throw error;\n              }\n            } else {\n              loop.putWrites(task.id, task.writes);\n            }\n          }\n\n          if (debug) {\n            printStepWrites(\n              loop.step,\n              Object.values(loop.tasks)\n                .map((task) => task.writes)\n                .flat(),\n              this.streamChannelsList as string[]\n            );\n          }\n        }\n        if (loop.status === \"out_of_steps\") {\n          throw new GraphRecursionError(\n            [\n              `Recursion limit of ${config.recursionLimit} reached`,\n              \"without hitting a stop condition. You can increase the\",\n              `limit by setting the \"recursionLimit\" config key.`,\n            ].join(\" \"),\n            {\n              lc_error_code: \"GRAPH_RECURSION_LIMIT\",\n            }\n          );\n        }\n      } catch (e) {\n        loopError = e;\n      } finally {\n        try {\n          // Call `.stop()` again incase it was not called in the loop, e.g due to an error.\n          if (loop) {\n            await loop.store?.stop();\n          }\n          await Promise.all([\n            ...(loop?.checkpointerPromises ?? []),\n            ...Array.from(managed.values()).map((mv) => mv.promises()),\n          ]);\n        } catch (e) {\n          loopError = loopError ?? e;\n        }\n        if (loopError) {\n          // \"Causes any future interactions with the associated stream to error\".\n          // Wraps ReadableStreamDefaultController#error:\n          // https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultController/error\n          stream.error(loopError);\n        } else {\n          // Will end the iterator outside of this method,\n          // keeping previously enqueued chunks.\n          // Wraps ReadableStreamDefaultController#close:\n          // https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultController/close\n          stream.close();\n        }\n      }\n    };\n    const runLoopPromise = runLoop();\n    try {\n      for await (const chunk of stream) {\n        if (chunk === undefined) {\n          throw new Error(\"Data structure error.\");\n        }\n        const [namespace, mode, payload] = chunk;\n        if (streamMode.includes(mode)) {\n          if (streamSubgraphs && !streamModeSingle) {\n            yield [namespace, mode, payload];\n          } else if (!streamModeSingle) {\n            yield [mode, payload];\n          } else if (streamSubgraphs) {\n            yield [namespace, payload];\n          } else {\n            yield payload;\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(loopError);\n      throw e;\n    } finally {\n      await runLoopPromise;\n    }\n    await runManager?.handleChainEnd(loop?.output ?? {});\n  }\n\n  /**\n   * Run the graph with a single input and config.\n   * @param input The input to the graph.\n   * @param options The configuration to use for the run.\n   * @param options.streamMode The mode to stream output. Defaults to value set on initialization.\n   *   Options are \"values\", \"updates\", and \"debug\". Default is \"values\".\n   *     values: Emit the current values of the state for each step.\n   *     updates: Emit only the updates to the state for each step.\n   *         Output is a dict with the node name as key and the updated values as value.\n   *     debug: Emit debug events for each step.\n   * @param options.outputKeys The keys to stream. Defaults to all non-context channels.\n   * @param options.interruptBefore Nodes to interrupt before.\n   * @param options.interruptAfter Nodes to interrupt after.\n   * @param options.debug Whether to print debug information during execution.\n   */\n  override async invoke(\n    input: InputType | Command | null,\n    options?: Partial<PregelOptions<Nn, Cc, ConfigurableFieldType>>\n  ): Promise<OutputType> {\n    const streamMode = options?.streamMode ?? \"values\";\n    const config = {\n      ...options,\n      outputKeys: options?.outputKeys ?? this.outputChannels,\n      streamMode,\n    };\n    const chunks = [];\n    const stream = await this.stream(input, config);\n    for await (const chunk of stream) {\n      chunks.push(chunk);\n    }\n    if (streamMode === \"values\") {\n      return chunks[chunks.length - 1];\n    }\n    return chunks as OutputType;\n  }\n}\n",
    "last_modified": "Tue, 17 Dec 2024 17:05:28 GMT"
  },
  {
    "url": "https://github.com/langchain-ai/langgraphjs/blob/main/libs/langgraph/src/pregel/io.ts",
    "markdown": "import type {\n  CheckpointPendingWrite,\n  PendingWrite,\n} from \"@langchain/langgraph-checkpoint\";\nimport { validate } from \"uuid\";\n\nimport type { BaseChannel } from \"../channels/base.js\";\nimport type { PregelExecutableTask } from \"./types.js\";\nimport {\n  _isSend,\n  Command,\n  NULL_TASK_ID,\n  RESUME,\n  SELF,\n  TAG_HIDDEN,\n  TASKS,\n} from \"../constants.js\";\nimport { EmptyChannelError, InvalidUpdateError } from \"../errors.js\";\n\nexport function readChannel<C extends PropertyKey>(\n  channels: Record<C, BaseChannel>,\n  chan: C,\n  catchErrors: boolean = true,\n  returnException: boolean = false\n): unknown | null {\n  try {\n    return channels[chan].get();\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } catch (e: any) {\n    if (e.name === EmptyChannelError.unminifiable_name) {\n      if (returnException) {\n        return e;\n      } else if (catchErrors) {\n        return null;\n      }\n    }\n    throw e;\n  }\n}\n\nexport function readChannels<C extends PropertyKey>(\n  channels: Record<C, BaseChannel>,\n  select: C | Array<C>,\n  skipEmpty: boolean = true\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Record<string, any> | any {\n  if (Array.isArray(select)) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const values = {} as Record<C, any>;\n    for (const k of select) {\n      try {\n        values[k] = readChannel(channels, k, !skipEmpty);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } catch (e: any) {\n        if (e.name === EmptyChannelError.unminifiable_name) {\n          continue;\n        }\n      }\n    }\n    return values;\n  } else {\n    return readChannel(channels, select);\n  }\n}\n\n/**\n * Map input chunk to a sequence of pending writes in the form (channel, value).\n */\nexport function* mapCommand(\n  cmd: Command,\n  pendingWrites: CheckpointPendingWrite[]\n): Generator<[string, string, unknown]> {\n  if (cmd.graph === Command.PARENT) {\n    throw new InvalidUpdateError(\"There is no parent graph.\");\n  }\n  if (cmd.goto) {\n    let sends;\n    if (Array.isArray(cmd.goto)) {\n      sends = cmd.goto;\n    } else {\n      sends = [cmd.goto];\n    }\n    for (const send of sends) {\n      if (_isSend(send)) {\n        yield [NULL_TASK_ID, TASKS, send];\n      } else if (typeof send === \"string\") {\n        yield [NULL_TASK_ID, `branch:__start__:${SELF}:${send}`, \"__start__\"];\n      } else {\n        throw new Error(\n          `In Command.send, expected Send or string, got ${typeof send}`\n        );\n      }\n    }\n  }\n  if (cmd.resume) {\n    if (\n      typeof cmd.resume === \"object\" &&\n      Object.keys(cmd.resume).length &&\n      Object.keys(cmd.resume).every(validate)\n    ) {\n      for (const [tid, resume] of Object.entries(cmd.resume)) {\n        const existing =\n          pendingWrites\n            .filter((w) => w[0] === tid && w[1] === RESUME)\n            .map((w) => w[2])\n            .slice(0, 1) ?? [];\n        existing.push(resume);\n        yield [tid, RESUME, existing];\n      }\n    } else {\n      yield [NULL_TASK_ID, RESUME, cmd.resume];\n    }\n  }\n  if (cmd.update) {\n    if (typeof cmd.update !== \"object\" || !cmd.update) {\n      throw new Error(\n        \"Expected cmd.update to be a dict mapping channel names to update values\"\n      );\n    }\n    for (const [k, v] of Object.entries(cmd.update)) {\n      yield [NULL_TASK_ID, k, v];\n    }\n  }\n}\n\n/**\n * Map input chunk to a sequence of pending writes in the form [channel, value].\n */\nexport function* mapInput<C extends PropertyKey>(\n  inputChannels: C | Array<C>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  chunk?: any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Generator<[C, any]> {\n  if (chunk !== undefined && chunk !== null) {\n    if (\n      Array.isArray(inputChannels) &&\n      typeof chunk === \"object\" &&\n      !Array.isArray(chunk)\n    ) {\n      for (const k in chunk) {\n        if (inputChannels.includes(k as C)) {\n          yield [k as C, chunk[k]];\n        }\n      }\n    } else if (Array.isArray(inputChannels)) {\n      throw new Error(\n        `Input chunk must be an object when \"inputChannels\" is an array`\n      );\n    } else {\n      yield [inputChannels, chunk];\n    }\n  }\n}\n\n/**\n * Map pending writes (a sequence of tuples (channel, value)) to output chunk.\n */\nexport function* mapOutputValues<C extends PropertyKey>(\n  outputChannels: C | Array<C>,\n  pendingWrites: readonly PendingWrite<C>[] | true,\n  channels: Record<C, BaseChannel>\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Generator<Record<string, any>, any> {\n  if (Array.isArray(outputChannels)) {\n    if (\n      pendingWrites === true ||\n      pendingWrites.find(([chan, _]) => outputChannels.includes(chan))\n    ) {\n      yield readChannels(channels, outputChannels);\n    }\n  } else {\n    if (\n      pendingWrites === true ||\n      pendingWrites.some(([chan, _]) => chan === outputChannels)\n    ) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      yield readChannel(channels, outputChannels) as any;\n    }\n  }\n}\n\n/**\n * Map pending writes (a sequence of tuples (channel, value)) to output chunk.\n */\nexport function* mapOutputUpdates<N extends PropertyKey, C extends PropertyKey>(\n  outputChannels: C | Array<C>,\n  tasks: readonly [PregelExecutableTask<N, C>, PendingWrite<C>[]][],\n  cached?: boolean\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Generator<Record<N, Record<string, any> | any>> {\n  const outputTasks = tasks.filter(([task]) => {\n    return task.config === undefined || !task.config.tags?.includes(TAG_HIDDEN);\n  });\n  if (!outputTasks.length) {\n    return;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let updated: [N, Record<string, any>][];\n  if (!Array.isArray(outputChannels)) {\n    updated = outputTasks.flatMap(([task]) =>\n      task.writes\n        .filter(([chan, _]) => chan === outputChannels)\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        .map(([_, value]) => [task.name, value] as [N, Record<string, any>])\n    );\n  } else {\n    updated = outputTasks\n      .filter(([task]) =>\n        task.writes.some(([chan]) => outputChannels.includes(chan))\n      )\n      .map(([task]) => [\n        task.name,\n        Object.fromEntries(\n          task.writes.filter(([chan]) => outputChannels.includes(chan))\n        ),\n      ]);\n  }\n  const grouped = Object.fromEntries(\n    outputTasks.map(([t]) => [t.name, []])\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) as unknown as Record<N, Record<string, any>>;\n\n  for (const [node, value] of updated) {\n    grouped[node].push(value);\n  }\n\n  for (const [node, value] of Object.entries(grouped) as [\n    N,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Record<string, any>[]\n  ][]) {\n    if (value.length === 0) {\n      delete grouped[node];\n    } else if (value.length === 1) {\n      // TODO: Fix incorrect cast here\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      grouped[node] = value[0] as Record<string, any>[];\n    }\n  }\n  if (cached) {\n    grouped[\"__metadata__\" as N] = { cached };\n  }\n  yield grouped;\n}\n\nexport function single<T>(iter: IterableIterator<T>): T | null {\n  // eslint-disable-next-line no-unreachable-loop\n  for (const value of iter) {\n    return value;\n  }\n  return null;\n}\n",
    "last_modified": "Tue, 17 Dec 2024 17:05:28 GMT"
  },
  {
    "url": "https://github.com/langchain-ai/langgraphjs/blob/main/libs/langgraph/src/pregel/loop.ts",
    "markdown": "import type { RunnableConfig } from \"@langchain/core/runnables\";\nimport type { CallbackManagerForChainRun } from \"@langchain/core/callbacks/manager\";\nimport { IterableReadableStream } from \"@langchain/core/utils/stream\";\nimport {\n  BaseCheckpointSaver,\n  Checkpoint,\n  CheckpointTuple,\n  copyCheckpoint,\n  emptyCheckpoint,\n  PendingWrite,\n  CheckpointPendingWrite,\n  CheckpointMetadata,\n  All,\n  BaseStore,\n  AsyncBatchedStore,\n  WRITES_IDX_MAP,\n} from \"@langchain/langgraph-checkpoint\";\n\nimport {\n  BaseChannel,\n  createCheckpoint,\n  emptyChannels,\n} from \"../channels/base.js\";\nimport { PregelExecutableTask, StreamMode } from \"./types.js\";\nimport {\n  isCommand,\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  Command,\n  CONFIG_KEY_CHECKPOINT_MAP,\n  CONFIG_KEY_READ,\n  CONFIG_KEY_RESUMING,\n  CONFIG_KEY_STREAM,\n  ERROR,\n  INPUT,\n  INTERRUPT,\n  NULL_TASK_ID,\n  RESUME,\n  TAG_HIDDEN,\n} from \"../constants.js\";\nimport {\n  _applyWrites,\n  _prepareNextTasks,\n  increment,\n  shouldInterrupt,\n  WritesProtocol,\n} from \"./algo.js\";\nimport {\n  gatherIterator,\n  gatherIteratorSync,\n  prefixGenerator,\n} from \"../utils.js\";\nimport {\n  mapCommand,\n  mapInput,\n  mapOutputUpdates,\n  mapOutputValues,\n  readChannels,\n} from \"./io.js\";\nimport {\n  getSubgraphsSeenSet,\n  EmptyInputError,\n  GraphInterrupt,\n  isGraphInterrupt,\n  MultipleSubgraphsError,\n} from \"../errors.js\";\nimport { getNewChannelVersions, patchConfigurable } from \"./utils/index.js\";\nimport {\n  mapDebugTasks,\n  mapDebugCheckpoint,\n  mapDebugTaskResults,\n} from \"./debug.js\";\nimport { PregelNode } from \"./read.js\";\nimport { ManagedValueMapping, WritableManagedValue } from \"../managed/base.js\";\nimport { LangGraphRunnableConfig } from \"./runnable_types.js\";\n\nconst INPUT_DONE = Symbol.for(\"INPUT_DONE\");\nconst INPUT_RESUMING = Symbol.for(\"INPUT_RESUMING\");\nconst DEFAULT_LOOP_LIMIT = 25;\n\n// [namespace, streamMode, payload]\nexport type StreamChunk = [string[], StreamMode, unknown];\n\nexport type PregelLoopInitializeParams = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input?: any | Command;\n  config: RunnableConfig;\n  checkpointer?: BaseCheckpointSaver;\n  outputKeys: string | string[];\n  streamKeys: string | string[];\n  nodes: Record<string, PregelNode>;\n  channelSpecs: Record<string, BaseChannel>;\n  managed: ManagedValueMapping;\n  stream: IterableReadableWritableStream;\n  store?: BaseStore;\n  checkSubgraphs?: boolean;\n};\n\ntype PregelLoopParams = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input?: any | Command;\n  config: RunnableConfig;\n  checkpointer?: BaseCheckpointSaver;\n  checkpoint: Checkpoint;\n  checkpointMetadata: CheckpointMetadata;\n  checkpointPreviousVersions: Record<string, string | number>;\n  checkpointPendingWrites: CheckpointPendingWrite[];\n  checkpointConfig: RunnableConfig;\n  channels: Record<string, BaseChannel>;\n  managed: ManagedValueMapping;\n  step: number;\n  stop: number;\n  outputKeys: string | string[];\n  streamKeys: string | string[];\n  nodes: Record<string, PregelNode>;\n  checkpointNamespace: string[];\n  skipDoneTasks: boolean;\n  isNested: boolean;\n  stream: IterableReadableWritableStream;\n  store?: AsyncBatchedStore;\n  prevCheckpointConfig: RunnableConfig | undefined;\n};\n\nexport class IterableReadableWritableStream extends IterableReadableStream<StreamChunk> {\n  modes: Set<StreamMode>;\n\n  private controller: ReadableStreamDefaultController;\n\n  private passthroughFn?: (chunk: StreamChunk) => void;\n\n  constructor(params: {\n    passthroughFn?: (chunk: StreamChunk) => void;\n    modes: Set<StreamMode>;\n  }) {\n    let streamControllerPromiseResolver: (\n      controller: ReadableStreamDefaultController\n    ) => void;\n    const streamControllerPromise: Promise<ReadableStreamDefaultController> =\n      new Promise<ReadableStreamDefaultController>((resolve) => {\n        streamControllerPromiseResolver = resolve;\n      });\n\n    super({\n      start: (controller) => {\n        streamControllerPromiseResolver!(controller);\n      },\n    });\n\n    // .start() will always be called before the stream can be interacted\n    // with anyway\n    void streamControllerPromise.then((controller) => {\n      this.controller = controller;\n    });\n\n    this.passthroughFn = params.passthroughFn;\n    this.modes = params.modes;\n  }\n\n  push(chunk: StreamChunk) {\n    this.passthroughFn?.(chunk);\n    this.controller.enqueue(chunk);\n  }\n\n  close() {\n    try {\n      this.controller.close();\n    } catch (e) {\n      // pass\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  error(e: any) {\n    this.controller.error(e);\n  }\n}\n\nfunction createDuplexStream(...streams: IterableReadableWritableStream[]) {\n  return new IterableReadableWritableStream({\n    passthroughFn: (value: StreamChunk) => {\n      for (const stream of streams) {\n        if (stream.modes.has(value[1])) {\n          stream.push(value);\n        }\n      }\n    },\n    modes: new Set(streams.flatMap((s) => Array.from(s.modes))),\n  });\n}\n\nexport class PregelLoop {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protected input?: any | Command;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  output: any;\n\n  config: LangGraphRunnableConfig;\n\n  protected checkpointer?: BaseCheckpointSaver;\n\n  protected checkpointerGetNextVersion: (\n    current: number | undefined,\n    channel: BaseChannel\n  ) => number;\n\n  channels: Record<string, BaseChannel>;\n\n  managed: ManagedValueMapping;\n\n  protected checkpoint: Checkpoint;\n\n  protected checkpointConfig: RunnableConfig;\n\n  checkpointMetadata: CheckpointMetadata;\n\n  protected checkpointNamespace: string[];\n\n  protected checkpointPendingWrites: CheckpointPendingWrite[] = [];\n\n  protected checkpointPreviousVersions: Record<string, string | number>;\n\n  step: number;\n\n  protected stop: number;\n\n  protected outputKeys: string | string[];\n\n  protected streamKeys: string | string[];\n\n  protected nodes: Record<string, PregelNode>;\n\n  protected skipDoneTasks: boolean;\n\n  protected prevCheckpointConfig: RunnableConfig | undefined;\n\n  status:\n    | \"pending\"\n    | \"done\"\n    | \"interrupt_before\"\n    | \"interrupt_after\"\n    | \"out_of_steps\" = \"pending\";\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  tasks: Record<string, PregelExecutableTask<any, any>> = {};\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  stream: IterableReadableWritableStream;\n\n  checkpointerPromises: Promise<unknown>[] = [];\n\n  isNested: boolean;\n\n  protected _checkpointerChainedPromise: Promise<unknown> = Promise.resolve();\n\n  store?: AsyncBatchedStore;\n\n  constructor(params: PregelLoopParams) {\n    this.input = params.input;\n    this.checkpointer = params.checkpointer;\n    // TODO: if managed values no longer needs graph we can replace with\n    // managed_specs, channel_specs\n    if (this.checkpointer !== undefined) {\n      this.checkpointerGetNextVersion = this.checkpointer.getNextVersion.bind(\n        this.checkpointer\n      );\n    } else {\n      this.checkpointerGetNextVersion = increment;\n    }\n    this.checkpoint = params.checkpoint;\n    this.checkpointMetadata = params.checkpointMetadata;\n    this.checkpointPreviousVersions = params.checkpointPreviousVersions;\n    this.channels = params.channels;\n    this.managed = params.managed;\n    this.checkpointPendingWrites = params.checkpointPendingWrites;\n    this.step = params.step;\n    this.stop = params.stop;\n    this.config = params.config;\n    this.checkpointConfig = params.checkpointConfig;\n    this.isNested = params.isNested;\n    this.outputKeys = params.outputKeys;\n    this.streamKeys = params.streamKeys;\n    this.nodes = params.nodes;\n    this.skipDoneTasks = params.skipDoneTasks;\n    this.store = params.store;\n    this.stream = params.stream;\n    this.checkpointNamespace = params.checkpointNamespace;\n    this.prevCheckpointConfig = params.prevCheckpointConfig;\n  }\n\n  static async initialize(params: PregelLoopInitializeParams) {\n    let { config, stream } = params;\n    const { checkSubgraphs = true } = params;\n    if (\n      stream !== undefined &&\n      config.configurable?.[CONFIG_KEY_STREAM] !== undefined\n    ) {\n      stream = createDuplexStream(\n        stream,\n        config.configurable[CONFIG_KEY_STREAM]\n      );\n    }\n    const skipDoneTasks = config.configurable\n      ? !(\"checkpoint_id\" in config.configurable)\n      : true;\n    const isNested = CONFIG_KEY_READ in (config.configurable ?? {});\n    if (\n      !isNested &&\n      config.configurable?.checkpoint_ns !== undefined &&\n      config.configurable?.checkpoint_ns !== \"\"\n    ) {\n      config = patchConfigurable(config, {\n        checkpoint_ns: \"\",\n        checkpoint_id: undefined,\n      });\n    }\n    let checkpointConfig = config;\n    if (\n      config.configurable?.[CONFIG_KEY_CHECKPOINT_MAP] !== undefined &&\n      config.configurable?.[CONFIG_KEY_CHECKPOINT_MAP]?.[\n        config.configurable?.checkpoint_ns\n      ]\n    ) {\n      checkpointConfig = patchConfigurable(config, {\n        checkpoint_id:\n          config.configurable[CONFIG_KEY_CHECKPOINT_MAP][\n            config.configurable?.checkpoint_ns\n          ],\n      });\n    }\n    const checkpointNamespace =\n      config.configurable?.checkpoint_ns?.split(\n        CHECKPOINT_NAMESPACE_SEPARATOR\n      ) ?? [];\n\n    const saved: CheckpointTuple = (await params.checkpointer?.getTuple(\n      checkpointConfig\n    )) ?? {\n      config,\n      checkpoint: emptyCheckpoint(),\n      metadata: {\n        source: \"input\",\n        step: -2,\n        writes: null,\n        parents: {},\n      },\n      pendingWrites: [],\n    };\n    checkpointConfig = {\n      ...config,\n      ...saved.config,\n      configurable: {\n        checkpoint_ns: \"\",\n        ...config.configurable,\n        ...saved.config.configurable,\n      },\n    };\n    const prevCheckpointConfig = saved.parentConfig;\n    const checkpoint = copyCheckpoint(saved.checkpoint);\n    const checkpointMetadata = { ...saved.metadata } as CheckpointMetadata;\n    const checkpointPendingWrites = saved.pendingWrites ?? [];\n\n    const channels = emptyChannels(params.channelSpecs, checkpoint);\n\n    const step = (checkpointMetadata.step ?? 0) + 1;\n    const stop = step + (config.recursionLimit ?? DEFAULT_LOOP_LIMIT) + 1;\n    const checkpointPreviousVersions = { ...checkpoint.channel_versions };\n\n    const store = params.store\n      ? new AsyncBatchedStore(params.store)\n      : undefined;\n    if (store) {\n      // Start the store. This is a batch store, so it will run continuously\n      store.start();\n    }\n    if (checkSubgraphs && isNested && params.checkpointer !== undefined) {\n      if (getSubgraphsSeenSet().has(config.configurable?.checkpoint_ns)) {\n        throw new MultipleSubgraphsError(\n          [\n            \"Detected the same subgraph called multiple times by the same node.\",\n            \"This is not allowed if checkpointing is enabled.\",\n            \"\",\n            `You can disable checkpointing for a subgraph by compiling it with \".compile({ checkpointer: false });\"`,\n          ].join(\"\\n\"),\n          {\n            lc_error_code: \"MULTIPLE_SUBGRAPHS\",\n          }\n        );\n      } else {\n        getSubgraphsSeenSet().add(config.configurable?.checkpoint_ns);\n      }\n    }\n    return new PregelLoop({\n      input: params.input,\n      config,\n      checkpointer: params.checkpointer,\n      checkpoint,\n      checkpointMetadata,\n      checkpointConfig,\n      prevCheckpointConfig,\n      checkpointNamespace,\n      channels,\n      managed: params.managed,\n      isNested,\n      skipDoneTasks,\n      step,\n      stop,\n      checkpointPreviousVersions,\n      checkpointPendingWrites,\n      outputKeys: params.outputKeys ?? [],\n      streamKeys: params.streamKeys ?? [],\n      nodes: params.nodes,\n      stream,\n      store,\n    });\n  }\n\n  protected _checkpointerPutAfterPrevious(input: {\n    config: RunnableConfig;\n    checkpoint: Checkpoint;\n    metadata: CheckpointMetadata;\n    newVersions: Record<string, string | number>;\n  }) {\n    this._checkpointerChainedPromise = this._checkpointerChainedPromise.then(\n      () => {\n        return this.checkpointer?.put(\n          input.config,\n          input.checkpoint,\n          input.metadata,\n          input.newVersions\n        );\n      }\n    );\n    this.checkpointerPromises.push(this._checkpointerChainedPromise);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  protected async updateManagedValues(key: string, values: any[]) {\n    const mv = this.managed.get(key);\n    if (mv && \"update\" in mv && typeof mv.update === \"function\") {\n      await (mv as WritableManagedValue).update(values);\n    }\n  }\n\n  /**\n   * Put writes for a task, to be read by the next tick.\n   * @param taskId\n   * @param writes\n   */\n  putWrites(taskId: string, writes: PendingWrite<string>[]) {\n    let writesCopy = writes;\n    if (writesCopy.length === 0) {\n      return;\n    }\n\n    // deduplicate writes to special channels, last write wins\n    if (writesCopy.every(([key]) => key in WRITES_IDX_MAP)) {\n      writesCopy = Array.from(\n        new Map(writesCopy.map((w) => [w[0], w])).values()\n      );\n    }\n    // save writes\n    for (const [c, v] of writesCopy) {\n      const idx = this.checkpointPendingWrites.findIndex(\n        (w) => w[0] === taskId && w[1] === c\n      );\n      if (c in WRITES_IDX_MAP && idx !== -1) {\n        this.checkpointPendingWrites[idx] = [taskId, c, v];\n      } else {\n        this.checkpointPendingWrites.push([taskId, c, v]);\n      }\n    }\n\n    const putWritePromise = this.checkpointer?.putWrites(\n      {\n        ...this.checkpointConfig,\n        configurable: {\n          ...this.checkpointConfig.configurable,\n          checkpoint_ns: this.config.configurable?.checkpoint_ns ?? \"\",\n          checkpoint_id: this.checkpoint.id,\n        },\n      },\n      writesCopy,\n      taskId\n    );\n    if (putWritePromise !== undefined) {\n      this.checkpointerPromises.push(putWritePromise);\n    }\n\n    if (this.tasks) {\n      this._outputWrites(taskId, writesCopy);\n    }\n  }\n\n  _outputWrites(taskId: string, writes: [string, unknown][], cached = false) {\n    const task = this.tasks[taskId];\n    if (task !== undefined) {\n      if (\n        task.config !== undefined &&\n        (task.config.tags ?? []).includes(TAG_HIDDEN)\n      ) {\n        return;\n      }\n      if (\n        writes.length > 0 &&\n        writes[0][0] !== ERROR &&\n        writes[0][0] !== INTERRUPT\n      ) {\n        this._emit(\n          gatherIteratorSync(\n            prefixGenerator(\n              mapOutputUpdates(this.outputKeys, [[task, writes]], cached),\n              \"updates\"\n            )\n          )\n        );\n      }\n      if (!cached) {\n        this._emit(\n          gatherIteratorSync(\n            prefixGenerator(\n              mapDebugTaskResults(this.step, [[task, writes]], this.streamKeys),\n              \"debug\"\n            )\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   * Execute a single iteration of the Pregel loop.\n   * Returns true if more iterations are needed.\n   * @param params\n   */\n  async tick(params: {\n    inputKeys?: string | string[];\n    interruptAfter: string[] | All;\n    interruptBefore: string[] | All;\n    manager?: CallbackManagerForChainRun;\n  }): Promise<boolean> {\n    let tickError: Error | undefined;\n    try {\n      if (this.store && !this.store.isRunning) {\n        this.store?.start();\n      }\n      const {\n        inputKeys = [],\n        interruptAfter = [],\n        interruptBefore = [],\n        manager,\n      } = params;\n      if (this.status !== \"pending\") {\n        throw new Error(\n          `Cannot tick when status is no longer \"pending\". Current status: \"${this.status}\"`\n        );\n      }\n      if (![INPUT_DONE, INPUT_RESUMING].includes(this.input)) {\n        await this._first(inputKeys);\n      } else if (\n        Object.values(this.tasks).every(\n          (task) =>\n            task.writes.filter(([c]) => !(c in WRITES_IDX_MAP)).length > 0\n        )\n      ) {\n        const writes = Object.values(this.tasks).flatMap((t) => t.writes);\n        // All tasks have finished\n        const managedValueWrites = _applyWrites(\n          this.checkpoint,\n          this.channels,\n          Object.values(this.tasks),\n          this.checkpointerGetNextVersion\n        );\n        for (const [key, values] of Object.entries(managedValueWrites)) {\n          await this.updateManagedValues(key, values);\n        }\n        // produce values output\n        const valuesOutput = await gatherIterator(\n          prefixGenerator(\n            mapOutputValues(this.outputKeys, writes, this.channels),\n            \"values\"\n          )\n        );\n        this._emit(valuesOutput);\n        // clear pending writes\n        this.checkpointPendingWrites = [];\n        await this._putCheckpoint({\n          source: \"loop\",\n          writes:\n            mapOutputUpdates(\n              this.outputKeys,\n              Object.values(this.tasks).map((task) => [task, task.writes])\n            ).next().value ?? null,\n        });\n        // after execution, check if we should interrupt\n        if (\n          shouldInterrupt(\n            this.checkpoint,\n            interruptAfter,\n            Object.values(this.tasks)\n          )\n        ) {\n          this.status = \"interrupt_after\";\n          if (this.isNested) {\n            throw new GraphInterrupt();\n          } else {\n            return false;\n          }\n        }\n      } else {\n        return false;\n      }\n      if (this.step > this.stop) {\n        this.status = \"out_of_steps\";\n        return false;\n      }\n\n      const nextTasks = _prepareNextTasks(\n        this.checkpoint,\n        this.checkpointPendingWrites,\n        this.nodes,\n        this.channels,\n        this.managed,\n        this.config,\n        true,\n        {\n          step: this.step,\n          checkpointer: this.checkpointer,\n          isResuming: this.input === INPUT_RESUMING,\n          manager,\n          store: this.store,\n        }\n      );\n      this.tasks = nextTasks;\n\n      // Produce debug output\n      if (this.checkpointer) {\n        this._emit(\n          await gatherIterator(\n            prefixGenerator(\n              mapDebugCheckpoint(\n                this.step - 1, // printing checkpoint for previous step\n                this.checkpointConfig,\n                this.channels,\n                this.streamKeys,\n                this.checkpointMetadata,\n                Object.values(this.tasks),\n                this.checkpointPendingWrites,\n                this.prevCheckpointConfig\n              ),\n              \"debug\"\n            )\n          )\n        );\n      }\n\n      if (Object.values(this.tasks).length === 0) {\n        this.status = \"done\";\n        return false;\n      }\n      // if there are pending writes from a previous loop, apply them\n      if (this.skipDoneTasks && this.checkpointPendingWrites.length > 0) {\n        for (const [tid, k, v] of this.checkpointPendingWrites) {\n          if (k === ERROR || k === INTERRUPT || k === RESUME) {\n            continue;\n          }\n          const task = Object.values(this.tasks).find((t) => t.id === tid);\n          if (task) {\n            task.writes.push([k, v]);\n          }\n        }\n        for (const task of Object.values(this.tasks)) {\n          if (task.writes.length > 0) {\n            this._outputWrites(task.id, task.writes, true);\n          }\n        }\n      }\n      // if all tasks have finished, re-tick\n      if (Object.values(this.tasks).every((task) => task.writes.length > 0)) {\n        return this.tick({\n          inputKeys,\n          interruptAfter,\n          interruptBefore,\n          manager,\n        });\n      }\n\n      // Before execution, check if we should interrupt\n      if (\n        shouldInterrupt(\n          this.checkpoint,\n          interruptBefore,\n          Object.values(this.tasks)\n        )\n      ) {\n        this.status = \"interrupt_before\";\n        if (this.isNested) {\n          throw new GraphInterrupt();\n        } else {\n          return false;\n        }\n      }\n      // Produce debug output\n      const debugOutput = await gatherIterator(\n        prefixGenerator(\n          mapDebugTasks(this.step, Object.values(this.tasks)),\n          \"debug\"\n        )\n      );\n      this._emit(debugOutput);\n\n      return true;\n    } catch (e) {\n      tickError = e as Error;\n      if (!this._suppressInterrupt(tickError)) {\n        throw tickError;\n      } else {\n        this.output = readChannels(this.channels, this.outputKeys);\n      }\n      return false;\n    } finally {\n      if (tickError === undefined) {\n        this.output = readChannels(this.channels, this.outputKeys);\n      }\n    }\n  }\n\n  protected _suppressInterrupt(e?: Error): boolean {\n    return isGraphInterrupt(e) && !this.isNested;\n  }\n\n  /**\n   * Resuming from previous checkpoint requires\n   * - finding a previous checkpoint\n   * - receiving null input (outer graph) or RESUMING flag (subgraph)\n   */\n  protected async _first(inputKeys: string | string[]) {\n    const isResuming =\n      Object.keys(this.checkpoint.channel_versions).length !== 0 &&\n      (this.config.configurable?.[CONFIG_KEY_RESUMING] !== undefined ||\n        this.input === null ||\n        isCommand(this.input));\n    if (isCommand(this.input)) {\n      const writes: { [key: string]: PendingWrite[] } = {};\n      // group writes by task id\n      for (const [tid, key, value] of mapCommand(\n        this.input,\n        this.checkpointPendingWrites\n      )) {\n        if (writes[tid] === undefined) {\n          writes[tid] = [];\n        }\n        writes[tid].push([key, value]);\n      }\n      if (Object.keys(writes).length === 0) {\n        throw new EmptyInputError(\"Received empty Command input\");\n      }\n      // save writes\n      for (const [tid, ws] of Object.entries(writes)) {\n        this.putWrites(tid, ws);\n      }\n    }\n    // apply null writes\n    const nullWrites = (this.checkpointPendingWrites ?? [])\n      .filter((w) => w[0] === NULL_TASK_ID)\n      .map((w) => w.slice(1)) as PendingWrite<string>[];\n    if (nullWrites.length > 0) {\n      _applyWrites(\n        this.checkpoint,\n        this.channels,\n        [\n          {\n            name: INPUT,\n            writes: nullWrites,\n            triggers: [],\n          },\n        ],\n        this.checkpointerGetNextVersion\n      );\n    }\n    if (isResuming) {\n      for (const channelName of Object.keys(this.channels)) {\n        if (this.checkpoint.channel_versions[channelName] !== undefined) {\n          const version = this.checkpoint.channel_versions[channelName];\n          this.checkpoint.versions_seen[INTERRUPT] = {\n            ...this.checkpoint.versions_seen[INTERRUPT],\n            [channelName]: version,\n          };\n        }\n      }\n      // produce values output\n      const valuesOutput = await gatherIterator(\n        prefixGenerator(\n          mapOutputValues(this.outputKeys, true, this.channels),\n          \"values\"\n        )\n      );\n      this._emit(valuesOutput);\n    } else {\n      // map inputs to channel updates\n      const inputWrites = await gatherIterator(mapInput(inputKeys, this.input));\n      if (inputWrites.length === 0) {\n        throw new EmptyInputError(\n          `Received no input writes for ${JSON.stringify(inputKeys, null, 2)}`\n        );\n      }\n      const discardTasks = _prepareNextTasks(\n        this.checkpoint,\n        this.checkpointPendingWrites,\n        this.nodes,\n        this.channels,\n        this.managed,\n        this.config,\n        true,\n        { step: this.step }\n      );\n      _applyWrites(\n        this.checkpoint,\n        this.channels,\n        (Object.values(discardTasks) as WritesProtocol[]).concat([\n          {\n            name: INPUT,\n            writes: inputWrites as PendingWrite[],\n            triggers: [],\n          },\n        ]),\n        this.checkpointerGetNextVersion\n      );\n      // save input checkpoint\n      await this._putCheckpoint({\n        source: \"input\",\n        writes: Object.fromEntries(inputWrites),\n      });\n    }\n    // done with input\n    this.input = isResuming ? INPUT_RESUMING : INPUT_DONE;\n    if (!this.isNested) {\n      this.config = patchConfigurable(this.config, {\n        [CONFIG_KEY_RESUMING]: isResuming,\n      });\n    }\n  }\n\n  protected _emit(values: [StreamMode, unknown][]) {\n    for (const chunk of values) {\n      if (this.stream.modes.has(chunk[0])) {\n        this.stream.push([this.checkpointNamespace, ...chunk]);\n      }\n    }\n  }\n\n  protected async _putCheckpoint(\n    inputMetadata: Omit<CheckpointMetadata, \"step\" | \"parents\">\n  ) {\n    // Assign step\n    const metadata = {\n      ...inputMetadata,\n      step: this.step,\n      parents: this.config.configurable?.[CONFIG_KEY_CHECKPOINT_MAP] ?? {},\n    };\n    // Bail if no checkpointer\n    if (this.checkpointer !== undefined) {\n      // store the previous checkpoint config for debug events\n      this.prevCheckpointConfig = this.checkpointConfig?.configurable\n        ?.checkpoint_id\n        ? this.checkpointConfig\n        : undefined;\n\n      // create new checkpoint\n      this.checkpointMetadata = metadata;\n      // child graphs keep at most one checkpoint per parent checkpoint\n      // this is achieved by writing child checkpoints as progress is made\n      // (so that error recovery / resuming from interrupt don't lose work)\n      // but doing so always with an id equal to that of the parent checkpoint\n      this.checkpoint = createCheckpoint(\n        this.checkpoint,\n        this.channels,\n        this.step\n      );\n      this.checkpointConfig = {\n        ...this.checkpointConfig,\n        configurable: {\n          ...this.checkpointConfig.configurable,\n          checkpoint_ns: this.config.configurable?.checkpoint_ns ?? \"\",\n        },\n      };\n      const channelVersions = { ...this.checkpoint.channel_versions };\n      const newVersions = getNewChannelVersions(\n        this.checkpointPreviousVersions,\n        channelVersions\n      );\n      this.checkpointPreviousVersions = channelVersions;\n      // save it, without blocking\n      // if there's a previous checkpoint save in progress, wait for it\n      // ensuring checkpointers receive checkpoints in order\n      void this._checkpointerPutAfterPrevious({\n        config: { ...this.checkpointConfig },\n        checkpoint: copyCheckpoint(this.checkpoint),\n        metadata: { ...this.checkpointMetadata },\n        newVersions,\n      });\n      this.checkpointConfig = {\n        ...this.checkpointConfig,\n        configurable: {\n          ...this.checkpointConfig.configurable,\n          checkpoint_id: this.checkpoint.id,\n        },\n      };\n    }\n    this.step += 1;\n  }\n}\n",
    "last_modified": "Tue, 17 Dec 2024 17:05:28 GMT"
  },
  {
    "url": "https://github.com/langchain-ai/langgraphjs/blob/main/libs/langgraph/src/pregel/messages.ts",
    "markdown": "import { v4 } from \"uuid\";\nimport {\n  BaseCallbackHandler,\n  HandleLLMNewTokenCallbackFields,\n  NewTokenIndices,\n} from \"@langchain/core/callbacks/base\";\nimport {\n  AIMessageChunk,\n  BaseMessage,\n  isBaseMessage,\n} from \"@langchain/core/messages\";\nimport { Serialized } from \"@langchain/core/load/serializable\";\nimport {\n  ChatGeneration,\n  ChatGenerationChunk,\n  LLMResult,\n} from \"@langchain/core/outputs\";\nimport { ChainValues } from \"@langchain/core/utils/types\";\n\nimport { StreamChunk } from \"./loop.js\";\nimport { TAG_HIDDEN, TAG_NOSTREAM } from \"../constants.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Meta = [string[], Record<string, any>];\n\nfunction isChatGenerationChunk(x: unknown): x is ChatGenerationChunk {\n  return isBaseMessage((x as ChatGenerationChunk)?.message);\n}\n\n/**\n * A callback handler that implements stream_mode=messages.\n * Collects messages from (1) chat model stream events and (2) node outputs.\n */\n// TODO: Make this import and explicitly implement the\n// CallbackHandlerPrefersStreaming interface once we drop support for core 0.2\nexport class StreamMessagesHandler extends BaseCallbackHandler {\n  name = \"StreamMessagesHandler\";\n\n  streamFn: (streamChunk: StreamChunk) => void;\n\n  metadatas: Record<string, Meta> = {};\n\n  seen: Record<string, BaseMessage> = {};\n\n  emittedChatModelRunIds: Record<string, boolean> = {};\n\n  lc_prefer_streaming = true;\n\n  constructor(streamFn: (streamChunk: StreamChunk) => void) {\n    super();\n    this.streamFn = streamFn;\n  }\n\n  _emit(meta: Meta, message: BaseMessage, dedupe = false) {\n    if (\n      dedupe &&\n      message.id !== undefined &&\n      this.seen[message.id] !== undefined\n    ) {\n      return;\n    }\n    if (message.id === undefined) {\n      const id = v4();\n      // eslint-disable-next-line no-param-reassign\n      message.id = id;\n      // eslint-disable-next-line no-param-reassign\n      message.lc_kwargs.id = id;\n    }\n    this.seen[message.id!] = message;\n    this.streamFn([meta[0], \"messages\", [message, meta[1]]]);\n  }\n\n  handleChatModelStart(\n    _llm: Serialized,\n    _messages: BaseMessage[][],\n    runId: string,\n    _parentRunId?: string,\n    _extraParams?: Record<string, unknown>,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    name?: string\n  ) {\n    if (\n      metadata &&\n      // Include legacy LangGraph SDK tag\n      (!tags || !(tags.includes(TAG_NOSTREAM) && tags.includes(\"nostream\")))\n    ) {\n      this.metadatas[runId] = [\n        (metadata.langgraph_checkpoint_ns as string).split(\"|\"),\n        { tags, name, ...metadata },\n      ];\n    }\n  }\n\n  handleLLMNewToken(\n    token: string,\n    _idx: NewTokenIndices,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    fields?: HandleLLMNewTokenCallbackFields\n  ) {\n    const chunk = fields?.chunk;\n    this.emittedChatModelRunIds[runId] = true;\n    if (isChatGenerationChunk(chunk) && this.metadatas[runId] !== undefined) {\n      this._emit(this.metadatas[runId], chunk.message);\n    } else {\n      this._emit(\n        this.metadatas[runId],\n        new AIMessageChunk({\n          content: token,\n        })\n      );\n    }\n  }\n\n  handleLLMEnd(output: LLMResult, runId: string) {\n    // In JS, non-streaming runs do not call handleLLMNewToken at the model level\n    if (!this.emittedChatModelRunIds[runId]) {\n      const chatGeneration = output.generations?.[0]?.[0] as ChatGeneration;\n      if (isBaseMessage(chatGeneration?.message)) {\n        this._emit(this.metadatas[runId], chatGeneration?.message, true);\n      }\n      delete this.emittedChatModelRunIds[runId];\n    }\n    delete this.metadatas[runId];\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  handleLLMError(_err: any, runId: string) {\n    delete this.metadatas[runId];\n  }\n\n  handleChainStart(\n    _chain: Serialized,\n    _inputs: ChainValues,\n    runId: string,\n    _parentRunId?: string,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    _runType?: string,\n    name?: string\n  ) {\n    if (\n      metadata !== undefined &&\n      name === metadata.langgraph_node &&\n      (tags === undefined || !tags.includes(TAG_HIDDEN))\n    ) {\n      this.metadatas[runId] = [\n        (metadata.langgraph_checkpoint_ns as string).split(\"|\"),\n        { tags, name, ...metadata },\n      ];\n    }\n  }\n\n  handleChainEnd(outputs: ChainValues, runId: string) {\n    const metadata = this.metadatas[runId];\n    delete this.metadatas[runId];\n    if (metadata !== undefined) {\n      if (isBaseMessage(outputs)) {\n        this._emit(metadata, outputs, true);\n      } else if (Array.isArray(outputs)) {\n        for (const value of outputs) {\n          if (isBaseMessage(value)) {\n            this._emit(metadata, value, true);\n          }\n        }\n      } else if (outputs != null && typeof outputs === \"object\") {\n        for (const value of Object.values(outputs)) {\n          if (isBaseMessage(value)) {\n            this._emit(metadata, value, true);\n          } else if (Array.isArray(value)) {\n            for (const item of value) {\n              if (isBaseMessage(item)) {\n                this._emit(metadata, item, true);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  handleChainError(_err: any, runId: string) {\n    delete this.metadatas[runId];\n  }\n}\n",
    "last_modified": "Tue, 17 Dec 2024 17:05:28 GMT"
  },
  {
    "url": "https://github.com/langchain-ai/langgraphjs/blob/main/libs/langgraph/src/pregel/read.ts",
    "markdown": "import {\n  Runnable,\n  RunnableBinding,\n  RunnableBindingArgs,\n  RunnableConfig,\n  RunnablePassthrough,\n  RunnableSequence,\n  _coerceToRunnable,\n  type RunnableLike,\n} from \"@langchain/core/runnables\";\nimport { CONFIG_KEY_READ } from \"../constants.js\";\nimport { ChannelWrite } from \"./write.js\";\nimport { RunnableCallable } from \"../utils.js\";\nimport type { RetryPolicy } from \"./utils/index.js\";\n\nexport class ChannelRead<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any\n> extends RunnableCallable {\n  lc_graph_name = \"ChannelRead\";\n\n  channel: string | Array<string>;\n\n  fresh: boolean = false;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  mapper?: (args: any) => any;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(\n    channel: string | Array<string>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    mapper?: (args: any) => any,\n    fresh: boolean = false\n  ) {\n    super({\n      func: (_: RunInput, config: RunnableConfig) =>\n        ChannelRead.doRead(config, this.channel, this.fresh, this.mapper),\n    });\n    this.fresh = fresh;\n    this.mapper = mapper;\n    this.channel = channel;\n    this.name = Array.isArray(channel)\n      ? `ChannelRead<${channel.join(\",\")}>`\n      : `ChannelRead<${channel}>`;\n  }\n\n  static doRead<T = unknown>(\n    config: RunnableConfig,\n    channel: string | Array<string>,\n    fresh: boolean,\n    mapper?: (args: unknown) => unknown\n  ): T {\n    const read: (arg: string | string[], fresh: boolean) => unknown =\n      config.configurable?.[CONFIG_KEY_READ];\n    if (!read) {\n      throw new Error(\n        `Runnable ${this} is not configured with a read function. Make sure to call in the context of a Pregel process`\n      );\n    }\n    if (mapper) {\n      return mapper(read(channel, fresh)) as T;\n    } else {\n      return read(channel, fresh) as T;\n    }\n  }\n}\n\nconst defaultRunnableBound =\n  /* #__PURE__ */ new RunnablePassthrough<PregelNodeInputType>();\n\ninterface PregelNodeArgs<RunInput, RunOutput>\n  extends Partial<RunnableBindingArgs<RunInput, RunOutput>> {\n  channels: Record<string, string> | string[];\n  triggers: Array<string>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  mapper?: (args: any) => any;\n  writers?: Runnable<RunOutput, unknown>[];\n  tags?: string[];\n  bound?: Runnable<RunInput, RunOutput>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  kwargs?: Record<string, any>;\n  config?: RunnableConfig;\n  metadata?: Record<string, unknown>;\n  retryPolicy?: RetryPolicy;\n  subgraphs?: Runnable[];\n  ends?: string[];\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PregelNodeInputType = any;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PregelNodeOutputType = any;\n\nexport class PregelNode<\n  RunInput = PregelNodeInputType,\n  RunOutput = PregelNodeOutputType\n> extends RunnableBinding<RunInput, RunOutput, RunnableConfig> {\n  lc_graph_name = \"PregelNode\";\n\n  channels: Record<string, string> | string[];\n\n  triggers: string[] = [];\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  mapper?: (args: any) => any;\n\n  writers: Runnable[] = [];\n\n  bound: Runnable<RunInput, RunOutput> = defaultRunnableBound;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  kwargs: Record<string, any> = {};\n\n  metadata: Record<string, unknown> = {};\n\n  tags: string[] = [];\n\n  retryPolicy?: RetryPolicy;\n\n  subgraphs?: Runnable[];\n\n  ends?: string[];\n\n  constructor(fields: PregelNodeArgs<RunInput, RunOutput>) {\n    const {\n      channels,\n      triggers,\n      mapper,\n      writers,\n      bound,\n      kwargs,\n      metadata,\n      retryPolicy,\n      tags,\n      subgraphs,\n      ends,\n    } = fields;\n    const mergedTags = [\n      ...(fields.config?.tags ? fields.config.tags : []),\n      ...(tags ?? []),\n    ];\n\n    super({\n      ...fields,\n      bound:\n        fields.bound ??\n        (defaultRunnableBound as unknown as Runnable<RunInput, RunOutput>),\n      config: {\n        ...(fields.config ? fields.config : {}),\n        tags: mergedTags,\n      },\n    });\n\n    this.channels = channels;\n    this.triggers = triggers;\n    this.mapper = mapper;\n    this.writers = writers ?? this.writers;\n    this.bound = bound ?? this.bound;\n    this.kwargs = kwargs ?? this.kwargs;\n    this.metadata = metadata ?? this.metadata;\n    this.tags = mergedTags;\n    this.retryPolicy = retryPolicy;\n    this.subgraphs = subgraphs;\n    this.ends = ends;\n  }\n\n  getWriters(): Array<Runnable> {\n    const newWriters = [...this.writers];\n    while (\n      newWriters.length > 1 &&\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      newWriters[newWriters.length - 1] instanceof ChannelWrite &&\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      newWriters[newWriters.length - 2] instanceof ChannelWrite\n    ) {\n      // we can combine writes if they are consecutive\n      // careful to not modify the original writers list or ChannelWrite\n      const endWriters = newWriters.slice(-2) as ChannelWrite[];\n      const combinedWrites = endWriters[0].writes.concat(endWriters[1].writes);\n      newWriters[newWriters.length - 2] = new ChannelWrite(\n        combinedWrites,\n        endWriters[0].config?.tags\n      );\n      newWriters.pop();\n    }\n    return newWriters;\n  }\n\n  getNode(): Runnable<RunInput, RunOutput> | undefined {\n    const writers = this.getWriters();\n    if (this.bound === defaultRunnableBound && writers.length === 0) {\n      return undefined;\n    } else if (this.bound === defaultRunnableBound && writers.length === 1) {\n      return writers[0];\n    } else if (this.bound === defaultRunnableBound) {\n      return new RunnableSequence({\n        first: writers[0],\n        middle: writers.slice(1, writers.length - 1),\n        last: writers[writers.length - 1],\n        omitSequenceTags: true,\n      });\n    } else if (writers.length > 0) {\n      return new RunnableSequence({\n        first: this.bound,\n        middle: writers.slice(0, writers.length - 1),\n        last: writers[writers.length - 1],\n        omitSequenceTags: true,\n      });\n    } else {\n      return this.bound;\n    }\n  }\n\n  join(channels: Array<string>): PregelNode<RunInput, RunOutput> {\n    if (!Array.isArray(channels)) {\n      throw new Error(\"channels must be a list\");\n    }\n    if (typeof this.channels !== \"object\") {\n      throw new Error(\"all channels must be named when using .join()\");\n    }\n\n    return new PregelNode<RunInput, RunOutput>({\n      channels: {\n        ...this.channels,\n        ...Object.fromEntries(channels.map((chan) => [chan, chan])),\n      },\n      triggers: this.triggers,\n      mapper: this.mapper,\n      writers: this.writers,\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: this.config,\n      retryPolicy: this.retryPolicy,\n    });\n  }\n\n  pipe<NewRunOutput>(\n    coerceable: RunnableLike\n  ): PregelNode<RunInput, Exclude<NewRunOutput, Error>> {\n    if (ChannelWrite.isWriter(coerceable)) {\n      return new PregelNode<RunInput, Exclude<NewRunOutput, Error>>({\n        channels: this.channels,\n        triggers: this.triggers,\n        mapper: this.mapper,\n        writers: [...this.writers, coerceable],\n        bound: this.bound as unknown as PregelNode<\n          RunInput,\n          Exclude<NewRunOutput, Error>\n        >,\n        config: this.config,\n        kwargs: this.kwargs,\n        retryPolicy: this.retryPolicy,\n      });\n    } else if (this.bound === defaultRunnableBound) {\n      return new PregelNode<RunInput, Exclude<NewRunOutput, Error>>({\n        channels: this.channels,\n        triggers: this.triggers,\n        mapper: this.mapper,\n        writers: this.writers,\n        bound: _coerceToRunnable<RunInput, NewRunOutput>(coerceable),\n        config: this.config,\n        kwargs: this.kwargs,\n        retryPolicy: this.retryPolicy,\n      });\n    } else {\n      return new PregelNode<RunInput, Exclude<NewRunOutput, Error>>({\n        channels: this.channels,\n        triggers: this.triggers,\n        mapper: this.mapper,\n        writers: this.writers,\n        bound: this.bound.pipe(coerceable),\n        config: this.config,\n        kwargs: this.kwargs,\n        retryPolicy: this.retryPolicy,\n      });\n    }\n  }\n}\n",
    "last_modified": "Tue, 17 Dec 2024 17:05:28 GMT"
  },
  {
    "url": "https://github.com/langchain-ai/langgraphjs/blob/main/libs/langgraph/src/pregel/remote.ts",
    "markdown": "import {\n  Client,\n  type Checkpoint,\n  type ThreadState,\n} from \"@langchain/langgraph-sdk\";\nimport {\n  Graph as DrawableGraph,\n  Node as DrawableNode,\n} from \"@langchain/core/runnables/graph\";\nimport {\n  mergeConfigs,\n  Runnable,\n  RunnableConfig,\n} from \"@langchain/core/runnables\";\nimport {\n  All,\n  CheckpointListOptions,\n  CheckpointMetadata,\n} from \"@langchain/langgraph-checkpoint\";\nimport { StreamEvent } from \"@langchain/core/tracers/log_stream\";\nimport { IterableReadableStream } from \"@langchain/core/utils/stream\";\nimport { isBaseMessage } from \"@langchain/core/messages\";\n\nimport {\n  BaseChannel,\n  GraphInterrupt,\n  LangGraphRunnableConfig,\n  ManagedValueSpec,\n  RemoteException,\n} from \"../web.js\";\nimport { StrRecord } from \"./algo.js\";\nimport { PregelInputType, PregelOptions, PregelOutputType } from \"./index.js\";\nimport { PregelNode } from \"./read.js\";\nimport {\n  PregelParams,\n  PregelInterface,\n  PregelTaskDescription,\n  StateSnapshot,\n  StreamMode,\n} from \"./types.js\";\nimport {\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  CONFIG_KEY_STREAM,\n  INTERRUPT,\n} from \"../constants.js\";\n\nexport type RemoteGraphParams = Omit<\n  PregelParams<\n    StrRecord<string, PregelNode>,\n    StrRecord<string, BaseChannel | ManagedValueSpec>\n  >,\n  \"channels\" | \"nodes\" | \"inputChannels\" | \"outputChannels\"\n> & {\n  graphId: string;\n  client?: Client;\n  url?: string;\n  apiKey?: string;\n  headers?: Record<string, string>;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst _serializeInputs = (obj: any): any => {\n  if (obj === null || typeof obj !== \"object\") {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(_serializeInputs);\n  }\n\n  // Handle BaseMessage instances by converting them to a serializable format\n  if (isBaseMessage(obj)) {\n    const dict = obj.toDict();\n    return {\n      ...dict.data,\n      role: obj.getType(),\n    };\n  }\n\n  return Object.fromEntries(\n    Object.entries(obj).map(([key, value]) => [key, _serializeInputs(value)])\n  );\n};\n\n/**\n * Return a tuple of the final list of stream modes sent to the\n * remote graph and a boolean flag indicating if only one stream mode was\n * originally requested and whether stream mode 'updates'\n * was present in the original list of stream modes.\n *\n * 'updates' mode is always added to the list of stream modes so that interrupts\n * can be detected in the remote graph.\n */\nconst getStreamModes = (\n  streamMode?: StreamMode | StreamMode[],\n  defaultStreamMode: StreamMode = \"updates\"\n) => {\n  const updatedStreamModes: StreamMode[] = [];\n  let reqUpdates = false;\n  let reqSingle = true;\n\n  if (\n    streamMode !== undefined &&\n    (typeof streamMode === \"string\" ||\n      (Array.isArray(streamMode) && streamMode.length > 0))\n  ) {\n    if (typeof streamMode === \"string\") {\n      updatedStreamModes.push(streamMode);\n    } else {\n      reqSingle = false;\n      updatedStreamModes.push(...streamMode);\n    }\n  } else {\n    updatedStreamModes.push(defaultStreamMode);\n  }\n  // TODO: Map messages to messages-tuple\n  if (updatedStreamModes.includes(\"updates\")) {\n    reqUpdates = true;\n  } else {\n    updatedStreamModes.push(\"updates\");\n  }\n  return {\n    updatedStreamModes,\n    reqUpdates,\n    reqSingle,\n  };\n};\n\n/**\n * The `RemoteGraph` class is a client implementation for calling remote\n * APIs that implement the LangGraph Server API specification.\n *\n * For example, the `RemoteGraph` class can be used to call APIs from deployments\n * on LangGraph Cloud.\n *\n * `RemoteGraph` behaves the same way as a `StateGraph` and can be used directly as\n * a node in another `StateGraph`.\n *\n * @example\n * ```ts\n * import { RemoteGraph } from \"@langchain/langgraph/remote\";\n *\n * // Can also pass a LangGraph SDK client instance directly\n * const remoteGraph = new RemoteGraph({\n *   graphId: process.env.LANGGRAPH_REMOTE_GRAPH_ID!,\n *   apiKey: process.env.LANGGRAPH_REMOTE_GRAPH_API_KEY,\n *   url: process.env.LANGGRAPH_REMOTE_GRAPH_API_URL,\n * });\n *\n * const input = {\n *   messages: [\n *     {\n *       role: \"human\",\n *       content: \"Hello world!\",\n *     },\n *   ],\n * };\n *\n * const config = {\n *   configurable: { thread_id: \"threadId1\" },\n * };\n *\n * await remoteGraph.invoke(input, config);\n * ```\n */\nexport class RemoteGraph<\n    Nn extends StrRecord<string, PregelNode> = StrRecord<string, PregelNode>,\n    Cc extends StrRecord<string, BaseChannel | ManagedValueSpec> = StrRecord<\n      string,\n      BaseChannel | ManagedValueSpec\n    >,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ConfigurableFieldType extends Record<string, any> = StrRecord<string, any>\n  >\n  extends Runnable<\n    PregelInputType,\n    PregelOutputType,\n    PregelOptions<Nn, Cc, ConfigurableFieldType>\n  >\n  implements PregelInterface<Nn, Cc, ConfigurableFieldType>\n{\n  static lc_name() {\n    return \"RemoteGraph\";\n  }\n\n  lc_namespace = [\"langgraph\", \"pregel\"];\n\n  lg_is_pregel = true;\n\n  config?: RunnableConfig;\n\n  graphId: string;\n\n  protected client: Client;\n\n  protected interruptBefore?: Array<keyof Nn> | All;\n\n  protected interruptAfter?: Array<keyof Nn> | All;\n\n  constructor(params: RemoteGraphParams) {\n    super(params);\n\n    this.graphId = params.graphId;\n    this.client =\n      params.client ??\n      new Client({\n        apiUrl: params.url,\n        apiKey: params.apiKey,\n        defaultHeaders: params.headers,\n      });\n    this.config = params.config;\n    this.interruptBefore = params.interruptBefore;\n    this.interruptAfter = params.interruptAfter;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore Remove ignore when we remove support for 0.2 versions of core\n  override withConfig(config: RunnableConfig): typeof this {\n    const mergedConfig = mergeConfigs(this.config, config);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return new (this.constructor as any)({ ...this, config: mergedConfig });\n  }\n\n  protected _sanitizeConfig(config: RunnableConfig) {\n    const reservedConfigurableKeys = new Set([\n      \"callbacks\",\n      \"checkpoint_map\",\n      \"checkpoint_id\",\n      \"checkpoint_ns\",\n    ]);\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const sanitizeObj = (obj: any): any => {\n      // Remove non-JSON serializable fields from the given object\n      if (obj && typeof obj === \"object\") {\n        if (Array.isArray(obj)) {\n          return obj.map((v) => sanitizeObj(v));\n        } else {\n          return Object.fromEntries(\n            Object.entries(obj).map(([k, v]) => [k, sanitizeObj(v)])\n          );\n        }\n      }\n\n      try {\n        JSON.stringify(obj);\n        return obj;\n      } catch {\n        return null;\n      }\n    };\n\n    // Remove non-JSON serializable fields from the config\n    const sanitizedConfig = sanitizeObj(config);\n\n    // Only include configurable keys that are not reserved and\n    // not starting with \"__pregel_\" prefix\n    const newConfigurable = Object.fromEntries(\n      Object.entries(sanitizedConfig.configurable ?? {}).filter(\n        ([k]) => !reservedConfigurableKeys.has(k) && !k.startsWith(\"__pregel_\")\n      )\n    );\n\n    return {\n      tags: sanitizedConfig.tags ?? [],\n      metadata: sanitizedConfig.metadata ?? {},\n      configurable: newConfigurable,\n    };\n  }\n\n  protected _getConfig(checkpoint: Record<string, unknown>): RunnableConfig {\n    return {\n      configurable: {\n        thread_id: checkpoint.thread_id,\n        checkpoint_ns: checkpoint.checkpoint_ns,\n        checkpoint_id: checkpoint.checkpoint_id,\n        checkpoint_map: checkpoint.checkpoint_map ?? {},\n      },\n    };\n  }\n\n  protected _getCheckpoint(config?: RunnableConfig): Checkpoint | undefined {\n    if (config?.configurable === undefined) {\n      return undefined;\n    }\n\n    const checkpointKeys = [\n      \"thread_id\",\n      \"checkpoint_ns\",\n      \"checkpoint_id\",\n      \"checkpoint_map\",\n    ] as const;\n\n    const checkpoint = Object.fromEntries(\n      checkpointKeys\n        .map((key) => [key, config.configurable![key]])\n        .filter(([_, value]) => value !== undefined)\n    );\n\n    return Object.keys(checkpoint).length > 0 ? checkpoint : undefined;\n  }\n\n  protected _createStateSnapshot(state: ThreadState): StateSnapshot {\n    const tasks: PregelTaskDescription[] = state.tasks.map((task) => {\n      return {\n        id: task.id,\n        name: task.name,\n        error: task.error ? { message: task.error } : undefined,\n        interrupts: task.interrupts,\n        // eslint-disable-next-line no-nested-ternary\n        state: task.state\n          ? this._createStateSnapshot(task.state)\n          : task.checkpoint\n          ? { configurable: task.checkpoint }\n          : undefined,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        result: (task as any).result,\n      };\n    });\n\n    return {\n      values: state.values,\n      next: state.next ? [...state.next] : [],\n      config: {\n        configurable: {\n          thread_id: state.checkpoint.thread_id,\n          checkpoint_ns: state.checkpoint.checkpoint_ns,\n          checkpoint_id: state.checkpoint.checkpoint_id,\n          checkpoint_map: state.checkpoint.checkpoint_map ?? {},\n        },\n      },\n      metadata: state.metadata\n        ? (state.metadata as CheckpointMetadata)\n        : undefined,\n      createdAt: state.created_at ?? undefined,\n      parentConfig: state.parent_checkpoint\n        ? {\n            configurable: {\n              thread_id: state.parent_checkpoint.thread_id,\n              checkpoint_ns: state.parent_checkpoint.checkpoint_ns,\n              checkpoint_id: state.parent_checkpoint.checkpoint_id,\n              checkpoint_map: state.parent_checkpoint.checkpoint_map ?? {},\n            },\n          }\n        : undefined,\n      tasks,\n    };\n  }\n\n  override async invoke(\n    input: PregelInputType,\n    options?: Partial<PregelOptions<Nn, Cc, ConfigurableFieldType>>\n  ): Promise<PregelOutputType> {\n    let lastValue;\n    const stream = await this.stream(input, {\n      ...options,\n      streamMode: \"values\",\n    });\n    for await (const chunk of stream) {\n      lastValue = chunk;\n    }\n    return lastValue;\n  }\n\n  override streamEvents(\n    input: PregelInputType,\n    options: Partial<PregelOptions<Nn, Cc, ConfigurableFieldType>> & {\n      version: \"v1\" | \"v2\";\n    }\n  ): IterableReadableStream<StreamEvent>;\n\n  override streamEvents(\n    input: PregelInputType,\n    options: Partial<PregelOptions<Nn, Cc, ConfigurableFieldType>> & {\n      version: \"v1\" | \"v2\";\n      encoding: never;\n    }\n  ): IterableReadableStream<never>;\n\n  override streamEvents(\n    _input: PregelInputType,\n    _options: Partial<PregelOptions<Nn, Cc, ConfigurableFieldType>> & {\n      version: \"v1\" | \"v2\";\n      encoding?: never;\n    }\n  ): IterableReadableStream<StreamEvent> {\n    throw new Error(\"Not implemented.\");\n  }\n\n  override async *_streamIterator(\n    input: PregelInputType,\n    options?: Partial<PregelOptions<Nn, Cc, ConfigurableFieldType>>\n  ): AsyncGenerator<PregelOutputType> {\n    const mergedConfig = mergeConfigs(this.config, options);\n    const sanitizedConfig = this._sanitizeConfig(mergedConfig);\n\n    const streamProtocolInstance = options?.configurable?.[CONFIG_KEY_STREAM];\n\n    const streamSubgraphs =\n      options?.subgraphs ?? streamProtocolInstance !== undefined;\n\n    const interruptBefore = this.interruptBefore ?? options?.interruptBefore;\n    const interruptAfter = this.interruptAfter ?? options?.interruptAfter;\n\n    const { updatedStreamModes, reqSingle, reqUpdates } = getStreamModes(\n      options?.streamMode\n    );\n\n    const extendedStreamModes = [\n      ...new Set([\n        ...updatedStreamModes,\n        ...(streamProtocolInstance?.modes ?? new Set()),\n      ]),\n    ];\n\n    for await (const chunk of this.client.runs.stream(\n      sanitizedConfig.configurable.thread_id as string,\n      this.graphId,\n      {\n        input: _serializeInputs(input),\n        config: sanitizedConfig,\n        streamMode: extendedStreamModes,\n        interruptBefore: interruptBefore as string[],\n        interruptAfter: interruptAfter as string[],\n        streamSubgraphs,\n        ifNotExists: \"create\",\n      }\n    )) {\n      let mode;\n      let namespace: string[];\n      if (chunk.event.includes(CHECKPOINT_NAMESPACE_SEPARATOR)) {\n        const eventComponents = chunk.event.split(\n          CHECKPOINT_NAMESPACE_SEPARATOR\n        );\n        // eslint-disable-next-line prefer-destructuring\n        mode = eventComponents[0];\n        namespace = eventComponents.slice(1);\n      } else {\n        mode = chunk.event;\n        namespace = [];\n      }\n      const callerNamespace = options?.configurable?.checkpoint_ns;\n      if (typeof callerNamespace === \"string\") {\n        namespace = callerNamespace\n          .split(CHECKPOINT_NAMESPACE_SEPARATOR)\n          .concat(namespace);\n      }\n      if (\n        streamProtocolInstance !== undefined &&\n        streamProtocolInstance.modes?.has(chunk.event)\n      ) {\n        streamProtocolInstance.push([namespace, mode, chunk.data]);\n      }\n      if (chunk.event.startsWith(\"updates\")) {\n        if (\n          typeof chunk.data === \"object\" &&\n          chunk.data?.[INTERRUPT] !== undefined\n        ) {\n          throw new GraphInterrupt(chunk.data[INTERRUPT]);\n        }\n        if (!reqUpdates) {\n          continue;\n        }\n      } else if (chunk.event?.startsWith(\"error\")) {\n        throw new RemoteException(\n          typeof chunk.data === \"string\"\n            ? chunk.data\n            : JSON.stringify(chunk.data)\n        );\n      }\n      if (\n        !updatedStreamModes.includes(\n          chunk.event.split(CHECKPOINT_NAMESPACE_SEPARATOR)[0] as StreamMode\n        )\n      ) {\n        continue;\n      }\n      if (options?.subgraphs) {\n        if (reqSingle) {\n          yield [namespace, chunk.data];\n        } else {\n          yield [namespace, mode, chunk.data];\n        }\n      } else if (reqSingle) {\n        yield chunk.data;\n      } else {\n        yield [mode, chunk.data];\n      }\n    }\n  }\n\n  async updateState(\n    inputConfig: LangGraphRunnableConfig,\n    values: Record<string, unknown>,\n    asNode?: string\n  ): Promise<RunnableConfig> {\n    const mergedConfig = mergeConfigs(this.config, inputConfig);\n    const response = await this.client.threads.updateState(\n      mergedConfig.configurable?.thread_id,\n      { values, asNode, checkpoint: this._getCheckpoint(mergedConfig) }\n    );\n    // TODO: Fix SDK typing\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return this._getConfig((response as any).checkpoint);\n  }\n\n  async *getStateHistory(\n    config: RunnableConfig,\n    options?: CheckpointListOptions\n  ): AsyncIterableIterator<StateSnapshot> {\n    const mergedConfig = mergeConfigs(this.config, config);\n    const states = await this.client.threads.getHistory(\n      mergedConfig.configurable?.thread_id,\n      {\n        limit: options?.limit ?? 10,\n        // TODO: Fix type\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        before: this._getCheckpoint(options?.before) as any,\n        metadata: options?.filter,\n        checkpoint: this._getCheckpoint(mergedConfig),\n      }\n    );\n    for (const state of states) {\n      yield this._createStateSnapshot(state);\n    }\n  }\n\n  protected _getDrawableNodes(\n    nodes: Array<{\n      id: string | number;\n      name?: string;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      data?: Record<string, any> | string;\n      metadata?: unknown;\n    }>\n  ): Record<string, DrawableNode> {\n    const nodesMap: Record<string, DrawableNode> = {};\n    for (const node of nodes) {\n      const nodeId = node.id;\n      nodesMap[nodeId] = {\n        id: nodeId.toString(),\n        name: typeof node.data === \"string\" ? node.data : node.data?.name ?? \"\",\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        data: (node.data as any) ?? {},\n        metadata:\n          typeof node.data !== \"string\" ? node.data?.metadata ?? {} : {},\n      };\n    }\n    return nodesMap;\n  }\n\n  async getState(\n    config: RunnableConfig,\n    options?: { subgraphs?: boolean }\n  ): Promise<StateSnapshot> {\n    const mergedConfig = mergeConfigs(this.config, config);\n\n    const state = await this.client.threads.getState(\n      mergedConfig.configurable?.thread_id,\n      this._getCheckpoint(mergedConfig),\n      options\n    );\n    return this._createStateSnapshot(state);\n  }\n\n  /** @deprecated Use getGraphAsync instead. The async method will become the default in the next minor release. */\n  override getGraph(\n    _?: RunnableConfig & { xray?: boolean | number }\n  ): DrawableGraph {\n    throw new Error(\n      `The synchronous \"getGraph\" is not supported for this graph. Call \"getGraphAsync\" instead.`\n    );\n  }\n\n  /**\n   * Returns a drawable representation of the computation graph.\n   */\n  async getGraphAsync(config?: RunnableConfig & { xray?: boolean | number }) {\n    const graph = await this.client.assistants.getGraph(this.graphId, {\n      xray: config?.xray,\n    });\n    return new DrawableGraph({\n      nodes: this._getDrawableNodes(graph.nodes),\n      edges: graph.edges,\n    });\n  }\n\n  /** @deprecated Use getSubgraphsAsync instead. The async method will become the default in the next minor release. */\n  getSubgraphs(): Generator<\n    [string, PregelInterface<Nn, Cc, ConfigurableFieldType>]\n  > {\n    throw new Error(\n      `The synchronous \"getSubgraphs\" method is not supported for this graph. Call \"getSubgraphsAsync\" instead.`\n    );\n  }\n\n  async *getSubgraphsAsync(\n    namespace?: string,\n    recurse = false\n  ): AsyncGenerator<[string, PregelInterface<Nn, Cc, ConfigurableFieldType>]> {\n    const subgraphs = await this.client.assistants.getSubgraphs(this.graphId, {\n      namespace,\n      recurse,\n    });\n\n    for (const [ns, graphSchema] of Object.entries(subgraphs)) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const remoteSubgraph = new (this.constructor as any)({\n        ...this,\n        graphId: graphSchema.graph_id,\n      });\n      yield [ns, remoteSubgraph];\n    }\n  }\n}\n",
    "last_modified": "Tue, 17 Dec 2024 17:05:28 GMT"
  },
  {
    "url": "https://github.com/langchain-ai/langgraphjs/blob/main/libs/langgraph/src/pregel/retry.ts",
    "markdown": "import { CHECKPOINT_NAMESPACE_SEPARATOR, Command } from \"../constants.js\";\nimport {\n  getSubgraphsSeenSet,\n  isGraphBubbleUp,\n  isParentCommand,\n} from \"../errors.js\";\nimport { PregelExecutableTask } from \"./types.js\";\nimport type { RetryPolicy } from \"./utils/index.js\";\n\nexport const DEFAULT_INITIAL_INTERVAL = 500;\nexport const DEFAULT_BACKOFF_FACTOR = 2;\nexport const DEFAULT_MAX_INTERVAL = 128000;\nexport const DEFAULT_MAX_RETRIES = 3;\n\nconst DEFAULT_STATUS_NO_RETRY = [\n  400, // Bad Request\n  401, // Unauthorized\n  402, // Payment Required\n  403, // Forbidden\n  404, // Not Found\n  405, // Method Not Allowed\n  406, // Not Acceptable\n  407, // Proxy Authentication Required\n  409, // Conflict\n];\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst DEFAULT_RETRY_ON_HANDLER = (error: any) => {\n  if (\n    error.message.startsWith(\"Cancel\") ||\n    error.message.startsWith(\"AbortError\") ||\n    error.name === \"AbortError\"\n  ) {\n    return false;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  if ((error as any)?.code === \"ECONNABORTED\") {\n    return false;\n  }\n  const status =\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (error as any)?.response?.status ?? (error as any)?.status;\n  if (status && DEFAULT_STATUS_NO_RETRY.includes(+status)) {\n    return false;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  if ((error as any)?.error?.code === \"insufficient_quota\") {\n    return false;\n  }\n  return true;\n};\n\nexport type SettledPregelTask = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  task: PregelExecutableTask<any, any>;\n  error: Error;\n};\n\nexport async function* executeTasksWithRetry(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  tasks: PregelExecutableTask<any, any>[],\n  options?: {\n    stepTimeout?: number;\n    signal?: AbortSignal;\n    retryPolicy?: RetryPolicy;\n  }\n): AsyncGenerator<SettledPregelTask> {\n  const { stepTimeout, retryPolicy } = options ?? {};\n  let signal = options?.signal;\n  // Start tasks\n  const executingTasksMap = Object.fromEntries(\n    tasks.map((pregelTask) => {\n      return [pregelTask.id, _runWithRetry(pregelTask, retryPolicy)];\n    })\n  );\n  if (stepTimeout && signal) {\n    if (\"any\" in AbortSignal) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      signal = (AbortSignal as any).any([\n        signal,\n        AbortSignal.timeout(stepTimeout),\n      ]);\n    }\n  } else if (stepTimeout) {\n    signal = AbortSignal.timeout(stepTimeout);\n  }\n\n  // Abort if signal is aborted\n  signal?.throwIfAborted();\n\n  let listener: () => void;\n  const signalPromise = new Promise<never>((_resolve, reject) => {\n    listener = () => reject(new Error(\"Abort\"));\n    signal?.addEventListener(\"abort\", listener);\n  }).finally(() => signal?.removeEventListener(\"abort\", listener));\n\n  while (Object.keys(executingTasksMap).length > 0) {\n    const settledTask = await Promise.race([\n      ...Object.values(executingTasksMap),\n      signalPromise,\n    ]);\n    yield settledTask;\n    delete executingTasksMap[settledTask.task.id];\n  }\n}\n\nasync function _runWithRetry(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  pregelTask: PregelExecutableTask<any, any>,\n  retryPolicy?: RetryPolicy\n) {\n  const resolvedRetryPolicy = pregelTask.retry_policy ?? retryPolicy;\n  let interval =\n    resolvedRetryPolicy !== undefined\n      ? resolvedRetryPolicy.initialInterval ?? DEFAULT_INITIAL_INTERVAL\n      : 0;\n  let attempts = 0;\n  let error;\n  let result;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    // Modify writes in place to clear any previous retries\n    while (pregelTask.writes.length > 0) {\n      pregelTask.writes.pop();\n    }\n    error = undefined;\n    try {\n      result = await pregelTask.proc.invoke(\n        pregelTask.input,\n        pregelTask.config\n      );\n      break;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e: any) {\n      error = e;\n      error.pregelTaskId = pregelTask.id;\n      if (isParentCommand(error)) {\n        const ns: string = pregelTask.config?.configurable?.checkpoint_ns;\n        const cmd = error.command;\n        if (cmd.graph === ns) {\n          // this command is for the current graph, handle it\n          for (const writer of pregelTask.writers) {\n            await writer.invoke(cmd, pregelTask.config);\n          }\n          break;\n        } else if (cmd.graph === Command.PARENT) {\n          // this command is for the parent graph, assign it to the parent\n          const parent_ns = ns\n            .split(CHECKPOINT_NAMESPACE_SEPARATOR)\n            .slice(0, -1)\n            .join(CHECKPOINT_NAMESPACE_SEPARATOR);\n          error.command = new Command({\n            ...error.command,\n            graph: parent_ns,\n          });\n        }\n      }\n      if (isGraphBubbleUp(error)) {\n        break;\n      }\n      if (resolvedRetryPolicy === undefined) {\n        break;\n      }\n      attempts += 1;\n      // check if we should give up\n      if (\n        attempts >= (resolvedRetryPolicy.maxAttempts ?? DEFAULT_MAX_RETRIES)\n      ) {\n        break;\n      }\n      const retryOn = resolvedRetryPolicy.retryOn ?? DEFAULT_RETRY_ON_HANDLER;\n      if (!retryOn(error)) {\n        break;\n      }\n      interval = Math.min(\n        resolvedRetryPolicy.maxInterval ?? DEFAULT_MAX_INTERVAL,\n        interval * (resolvedRetryPolicy.backoffFactor ?? DEFAULT_BACKOFF_FACTOR)\n      );\n      const intervalWithJitter = resolvedRetryPolicy.jitter\n        ? Math.floor(interval + Math.random() * 1000)\n        : interval;\n      // sleep before retrying\n      // eslint-disable-next-line no-promise-executor-return\n      await new Promise((resolve) => setTimeout(resolve, intervalWithJitter));\n      // log the retry\n      const errorName =\n        error.name ??\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (error.constructor as any).unminifiable_name ??\n        error.constructor.name;\n      console.log(\n        `Retrying task \"${pregelTask.name}\" after ${interval.toFixed(\n          2\n        )}ms (attempt ${attempts}) after ${errorName}: ${error}`\n      );\n    } finally {\n      // Clear checkpoint_ns seen (for subgraph detection)\n      const checkpointNs = pregelTask.config?.configurable?.checkpoint_ns;\n      if (checkpointNs) {\n        getSubgraphsSeenSet().delete(checkpointNs);\n      }\n    }\n  }\n  return {\n    task: pregelTask,\n    result,\n    error,\n  };\n}\n",
    "last_modified": "Tue, 17 Dec 2024 17:05:28 GMT"
  },
  {
    "url": "https://github.com/langchain-ai/langgraphjs/blob/main/libs/langgraph/src/pregel/runnable_types.ts",
    "markdown": "import { RunnableConfig } from \"@langchain/core/runnables\";\nimport { BaseStore } from \"@langchain/langgraph-checkpoint\";\n\nexport interface LangGraphRunnableConfig<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ConfigurableType extends Record<string, any> = Record<string, any>\n> extends RunnableConfig<ConfigurableType> {\n  store?: BaseStore;\n\n  writer?: (chunk: unknown) => void;\n}\n",
    "last_modified": "Tue, 17 Dec 2024 17:05:28 GMT"
  },
  {
    "url": "https://github.com/langchain-ai/langgraphjs/blob/main/libs/langgraph/src/pregel/types.ts",
    "markdown": "import type { Runnable, RunnableConfig } from \"@langchain/core/runnables\";\nimport type {\n  All,\n  PendingWrite,\n  CheckpointMetadata,\n  BaseCheckpointSaver,\n  BaseStore,\n  CheckpointListOptions,\n} from \"@langchain/langgraph-checkpoint\";\nimport { Graph as DrawableGraph } from \"@langchain/core/runnables/graph\";\nimport { IterableReadableStream } from \"@langchain/core/utils/stream\";\nimport type { BaseChannel } from \"../channels/base.js\";\nimport type { PregelNode } from \"./read.js\";\nimport { RetryPolicy } from \"./utils/index.js\";\nimport { Interrupt } from \"../constants.js\";\nimport { type ManagedValueSpec } from \"../managed/base.js\";\nimport { LangGraphRunnableConfig } from \"./runnable_types.js\";\n\nexport type StreamMode = \"values\" | \"updates\" | \"debug\" | \"messages\" | \"custom\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PregelInputType = any;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PregelOutputType = any;\n\n/**\n * Config for executing the graph.\n */\nexport interface PregelOptions<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel | ManagedValueSpec>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ConfigurableFieldType extends Record<string, any> = Record<string, any>\n> extends RunnableConfig<ConfigurableFieldType> {\n  /** The stream mode for the graph run. Default is [\"values\"]. */\n  streamMode?: StreamMode | StreamMode[];\n  inputKeys?: keyof Cc | Array<keyof Cc>;\n  /** The output keys to retrieve from the graph run. */\n  outputKeys?: keyof Cc | Array<keyof Cc>;\n  /** The nodes to interrupt the graph run before. */\n  interruptBefore?: All | Array<keyof Nn>;\n  /** The nodes to interrupt the graph run after. */\n  interruptAfter?: All | Array<keyof Nn>;\n  /** Enable debug mode for the graph run. */\n  debug?: boolean;\n  /** Whether to stream subgraphs. */\n  subgraphs?: boolean;\n  /** The shared value store */\n  store?: BaseStore;\n}\n\n/**\n * Construct a type with a set of properties K of type T\n */\ntype StrRecord<K extends string, T> = {\n  [P in K]: T;\n};\n\nexport interface PregelInterface<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel | ManagedValueSpec>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ConfigurableFieldType extends Record<string, any> = StrRecord<string, any>\n> {\n  lg_is_pregel: boolean;\n\n  withConfig(config: RunnableConfig): PregelInterface<Nn, Cc>;\n\n  getGraphAsync(\n    config: RunnableConfig & { xray?: boolean | number }\n  ): Promise<DrawableGraph>;\n\n  /** @deprecated Use getSubgraphsAsync instead. The async method will become the default in the next minor release. */\n  getSubgraphs(\n    namespace?: string,\n    recurse?: boolean\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Generator<[string, PregelInterface<any, any>]>;\n\n  getSubgraphsAsync(\n    namespace?: string,\n    recurse?: boolean\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): AsyncGenerator<[string, PregelInterface<any, any>]>;\n\n  getState(\n    config: RunnableConfig,\n    options?: { subgraphs?: boolean }\n  ): Promise<StateSnapshot>;\n\n  getStateHistory(\n    config: RunnableConfig,\n    options?: CheckpointListOptions\n  ): AsyncIterableIterator<StateSnapshot>;\n\n  updateState(\n    inputConfig: LangGraphRunnableConfig,\n    values: Record<string, unknown> | unknown,\n    asNode?: keyof Nn | string\n  ): Promise<RunnableConfig>;\n\n  stream(\n    input: PregelInputType,\n    options?: Partial<PregelOptions<Nn, Cc, ConfigurableFieldType>>\n  ): Promise<IterableReadableStream<PregelOutputType>>;\n\n  invoke(\n    input: PregelInputType,\n    options?: Partial<PregelOptions<Nn, Cc, ConfigurableFieldType>>\n  ): Promise<PregelOutputType>;\n}\n\nexport type PregelParams<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel | ManagedValueSpec>\n> = {\n  nodes: Nn;\n\n  channels: Cc;\n\n  /**\n   * @default true\n   */\n  autoValidate?: boolean;\n\n  /**\n   * @default \"values\"\n   */\n  streamMode?: StreamMode | StreamMode[];\n\n  inputChannels: keyof Cc | Array<keyof Cc>;\n\n  outputChannels: keyof Cc | Array<keyof Cc>;\n\n  /**\n   * @default []\n   */\n  interruptAfter?: Array<keyof Nn> | All;\n\n  /**\n   * @default []\n   */\n  interruptBefore?: Array<keyof Nn> | All;\n\n  streamChannels?: keyof Cc | Array<keyof Cc>;\n\n  /**\n   * @default undefined\n   */\n  stepTimeout?: number;\n\n  /**\n   * @default false\n   */\n  debug?: boolean;\n\n  checkpointer?: BaseCheckpointSaver | false;\n\n  retryPolicy?: RetryPolicy;\n\n  config?: LangGraphRunnableConfig;\n\n  /**\n   * Memory store to use for SharedValues.\n   */\n  store?: BaseStore;\n};\n\nexport interface PregelTaskDescription {\n  readonly id: string;\n  readonly name: string;\n  readonly error?: unknown;\n  readonly interrupts: Interrupt[];\n  readonly state?: LangGraphRunnableConfig | StateSnapshot;\n  readonly path?: [string, ...(string | number)[]];\n}\n\nexport interface PregelExecutableTask<\n  N extends PropertyKey,\n  C extends PropertyKey\n> {\n  readonly name: N;\n  readonly input: unknown;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly proc: Runnable<any, any, LangGraphRunnableConfig>;\n  readonly writes: PendingWrite<C>[];\n  readonly config?: LangGraphRunnableConfig;\n  readonly triggers: Array<string>;\n  readonly retry_policy?: RetryPolicy;\n  readonly id: string;\n  readonly path?: [string, ...(string | number)[]];\n  readonly subgraphs?: Runnable[];\n  readonly writers: Runnable[];\n}\n\nexport interface StateSnapshot {\n  /**\n   * Current values of channels\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  readonly values: Record<string, any> | any;\n  /**\n   * Nodes to execute in the next step, if any\n   */\n  readonly next: Array<string>;\n  /**\n   * Config used to fetch this snapshot\n   */\n  readonly config: RunnableConfig;\n  /**\n   * Metadata about the checkpoint\n   */\n  readonly metadata?: CheckpointMetadata;\n  /**\n   * Time when the snapshot was created\n   */\n  readonly createdAt?: string;\n  /**\n   * Config used to fetch the parent snapshot, if any\n   * @default undefined\n   */\n  readonly parentConfig?: RunnableConfig | undefined;\n  /**\n   * Tasks to execute in this step. If already attempted, may contain an error.\n   */\n  readonly tasks: PregelTaskDescription[];\n}\n\nexport type PregelScratchpad<Resume> = {\n  interruptCounter: number;\n  usedNullResume: boolean;\n  resume: Resume[];\n};\n",
    "last_modified": "Tue, 17 Dec 2024 17:05:28 GMT"
  },
  {
    "url": "https://github.com/langchain-ai/langgraphjs/blob/main/libs/langgraph/src/pregel/validate.ts",
    "markdown": "import { All } from \"@langchain/langgraph-checkpoint\";\nimport { BaseChannel } from \"../channels/index.js\";\nimport { INTERRUPT } from \"../constants.js\";\nimport { PregelNode } from \"./read.js\";\nimport { type ManagedValueSpec } from \"../managed/base.js\";\n\nexport class GraphValidationError extends Error {\n  constructor(message?: string) {\n    super(message);\n    this.name = \"GraphValidationError\";\n  }\n}\n\nexport function validateGraph<\n  Nn extends Record<string, PregelNode>,\n  Cc extends Record<string, BaseChannel | ManagedValueSpec>\n>({\n  nodes,\n  channels,\n  inputChannels,\n  outputChannels,\n  streamChannels,\n  interruptAfterNodes,\n  interruptBeforeNodes,\n}: {\n  nodes: Nn;\n  channels: Cc;\n  inputChannels: keyof Cc | Array<keyof Cc>;\n  outputChannels: keyof Cc | Array<keyof Cc>;\n  streamChannels?: keyof Cc | Array<keyof Cc>;\n  interruptAfterNodes?: Array<keyof Nn> | All;\n  interruptBeforeNodes?: Array<keyof Nn> | All;\n}): void {\n  if (!channels) {\n    throw new GraphValidationError(\"Channels not provided\");\n  }\n\n  const subscribedChannels = new Set<keyof Cc>();\n  const allOutputChannels = new Set<keyof Cc>();\n\n  for (const [name, node] of Object.entries(nodes)) {\n    if (name === INTERRUPT) {\n      throw new GraphValidationError(`\"Node name ${INTERRUPT} is reserved\"`);\n    }\n    if (node.constructor === PregelNode) {\n      node.triggers.forEach((trigger) => subscribedChannels.add(trigger));\n    } else {\n      throw new GraphValidationError(\n        `Invalid node type ${typeof node}, expected PregelNode`\n      );\n    }\n  }\n\n  // side effect: update channels\n  for (const chan of subscribedChannels) {\n    if (!(chan in channels)) {\n      throw new GraphValidationError(\n        `Subcribed channel '${String(chan)}' not in channels`\n      );\n    }\n  }\n\n  if (!Array.isArray(inputChannels)) {\n    if (!subscribedChannels.has(inputChannels)) {\n      throw new GraphValidationError(\n        `Input channel ${String(\n          inputChannels\n        )} is not subscribed to by any node`\n      );\n    }\n  } else {\n    if (inputChannels.every((channel) => !subscribedChannels.has(channel))) {\n      throw new GraphValidationError(\n        `None of the input channels ${inputChannels} are subscribed to by any node`\n      );\n    }\n  }\n\n  if (!Array.isArray(outputChannels)) {\n    allOutputChannels.add(outputChannels);\n  } else {\n    outputChannels.forEach((chan) => allOutputChannels.add(chan));\n  }\n\n  if (streamChannels && !Array.isArray(streamChannels)) {\n    allOutputChannels.add(streamChannels);\n  } else if (Array.isArray(streamChannels)) {\n    streamChannels.forEach((chan) => allOutputChannels.add(chan));\n  }\n\n  for (const chan of allOutputChannels) {\n    if (!(chan in channels)) {\n      throw new GraphValidationError(\n        `Output channel '${String(chan)}' not in channels`\n      );\n    }\n  }\n\n  // validate interrupt before/after\n  if (interruptAfterNodes && interruptAfterNodes !== \"*\") {\n    for (const node of interruptAfterNodes) {\n      if (!(node in nodes)) {\n        throw new GraphValidationError(`Node ${String(node)} not in nodes`);\n      }\n    }\n  }\n\n  if (interruptBeforeNodes && interruptBeforeNodes !== \"*\") {\n    for (const node of interruptBeforeNodes) {\n      if (!(node in nodes)) {\n        throw new GraphValidationError(`Node ${String(node)} not in nodes`);\n      }\n    }\n  }\n}\n\nexport function validateKeys<\n  Cc extends Record<string, BaseChannel | ManagedValueSpec>\n>(keys: keyof Cc | Array<keyof Cc>, channels: Cc): void {\n  if (Array.isArray(keys)) {\n    for (const key of keys) {\n      if (!(key in channels)) {\n        throw new Error(`Key ${String(key)} not found in channels`);\n      }\n    }\n  } else {\n    if (!(keys in channels)) {\n      throw new Error(`Key ${String(keys)} not found in channels`);\n    }\n  }\n}\n",
    "last_modified": "Tue, 17 Dec 2024 17:05:28 GMT"
  },
  {
    "url": "https://github.com/langchain-ai/langgraphjs/blob/main/libs/langgraph/src/pregel/write.ts",
    "markdown": "import {\n  Runnable,\n  RunnableConfig,\n  RunnableLike,\n} from \"@langchain/core/runnables\";\nimport { _isSend, CONFIG_KEY_SEND, Send, TASKS } from \"../constants.js\";\nimport { RunnableCallable } from \"../utils.js\";\nimport { InvalidUpdateError } from \"../errors.js\";\n\ntype TYPE_SEND = (values: Array<[string, unknown]>) => void;\n\nexport const SKIP_WRITE = {\n  [Symbol.for(\"LG_SKIP_WRITE\")]: true,\n};\n\nfunction _isSkipWrite(x: unknown) {\n  return (\n    typeof x === \"object\" &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (x as any)?.[Symbol.for(\"LG_SKIP_WRITE\")] !== undefined\n  );\n}\n\nexport const PASSTHROUGH = {\n  [Symbol.for(\"LG_PASSTHROUGH\")]: true,\n};\n\nfunction _isPassthrough(x: unknown) {\n  return (\n    typeof x === \"object\" &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (x as any)?.[Symbol.for(\"LG_PASSTHROUGH\")] !== undefined\n  );\n}\n\nconst IS_WRITER = Symbol(\"IS_WRITER\");\n\n/**\n * Mapping of write channels to Runnables that return the value to be written,\n * or None to skip writing.\n */\nexport class ChannelWrite<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any\n> extends RunnableCallable {\n  writes: Array<ChannelWriteEntry | ChannelWriteTupleEntry | Send>;\n\n  constructor(\n    writes: Array<ChannelWriteEntry | ChannelWriteTupleEntry | Send>,\n    tags?: string[]\n  ) {\n    const name = `ChannelWrite<${writes\n      .map((packet) => {\n        if (_isSend(packet)) {\n          return packet.node;\n        } else if (\"channel\" in packet) {\n          return packet.channel;\n        }\n        return \"...\";\n      })\n      .join(\",\")}>`;\n    super({\n      ...{ writes, name, tags },\n      func: async (input: RunInput, config?: RunnableConfig) => {\n        return this._write(input, config ?? {});\n      },\n    });\n\n    this.writes = writes;\n  }\n\n  async _write(input: unknown, config: RunnableConfig): Promise<unknown> {\n    const writes = this.writes.map((write) => {\n      if (_isChannelWriteTupleEntry(write) && _isPassthrough(write.value)) {\n        return {\n          mapper: write.mapper,\n          value: input,\n        };\n      } else if (_isChannelWriteEntry(write) && _isPassthrough(write.value)) {\n        return {\n          channel: write.channel,\n          value: input,\n          skipNone: write.skipNone,\n          mapper: write.mapper,\n        };\n      } else {\n        return write;\n      }\n    });\n    await ChannelWrite.doWrite(config, writes);\n    return input;\n  }\n\n  // TODO: Support requireAtLeastOneOf\n  static async doWrite(\n    config: RunnableConfig,\n    writes: (ChannelWriteEntry | ChannelWriteTupleEntry | Send)[]\n  ): Promise<void> {\n    // validate\n    for (const w of writes) {\n      if (_isChannelWriteEntry(w)) {\n        if (w.channel === TASKS) {\n          throw new InvalidUpdateError(\n            \"Cannot write to the reserved channel TASKS\"\n          );\n        }\n        if (_isPassthrough(w.value)) {\n          throw new InvalidUpdateError(\"PASSTHROUGH value must be replaced\");\n        }\n      }\n      if (_isChannelWriteTupleEntry(w)) {\n        if (_isPassthrough(w.value)) {\n          throw new InvalidUpdateError(\"PASSTHROUGH value must be replaced\");\n        }\n      }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const writeEntries: [string, any][] = [];\n    for (const w of writes) {\n      if (_isSend(w)) {\n        writeEntries.push([TASKS, w]);\n      } else if (_isChannelWriteTupleEntry(w)) {\n        const mappedResult = await w.mapper.invoke(w.value, config);\n        if (mappedResult != null && mappedResult.length > 0) {\n          writeEntries.push(...mappedResult);\n        }\n      } else if (_isChannelWriteEntry(w)) {\n        const mappedValue =\n          w.mapper !== undefined\n            ? await w.mapper.invoke(w.value, config)\n            : w.value;\n        if (_isSkipWrite(mappedValue)) {\n          continue;\n        }\n        if (w.skipNone && mappedValue === undefined) {\n          continue;\n        }\n        writeEntries.push([w.channel, mappedValue]);\n      } else {\n        throw new Error(`Invalid write entry: ${JSON.stringify(w)}`);\n      }\n    }\n    const write: TYPE_SEND = config.configurable?.[CONFIG_KEY_SEND];\n    write(writeEntries);\n  }\n\n  static isWriter(runnable: RunnableLike): runnable is ChannelWrite {\n    return (\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      runnable instanceof ChannelWrite ||\n      (IS_WRITER in runnable && !!runnable[IS_WRITER])\n    );\n  }\n\n  static registerWriter<T extends Runnable>(runnable: T): T {\n    return Object.defineProperty(runnable, IS_WRITER, { value: true });\n  }\n}\n\nexport interface ChannelWriteEntry {\n  channel: string;\n  value: unknown;\n  skipNone?: boolean;\n  mapper?: Runnable;\n}\n\nfunction _isChannelWriteEntry(x: unknown): x is ChannelWriteEntry {\n  return (\n    x !== undefined && typeof (x as ChannelWriteEntry).channel === \"string\"\n  );\n}\n\nexport interface ChannelWriteTupleEntry {\n  value: unknown;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  mapper: Runnable<any, [string, any][]>;\n}\n\nfunction _isChannelWriteTupleEntry(x: unknown): x is ChannelWriteTupleEntry {\n  return (\n    x !== undefined &&\n    !_isChannelWriteEntry(x) &&\n    Runnable.isRunnable((x as ChannelWriteTupleEntry).mapper)\n  );\n}\n",
    "last_modified": "Tue, 17 Dec 2024 17:05:28 GMT"
  },
  {
    "url": "https://github.com/langchain-ai/langgraphjs/blob/main/libs/langgraph/src/pregel/utils/config.ts",
    "markdown": "import { RunnableConfig } from \"@langchain/core/runnables\";\nimport { AsyncLocalStorageProviderSingleton } from \"@langchain/core/singletons\";\nimport { LangGraphRunnableConfig } from \"../runnable_types.js\";\n\nconst COPIABLE_KEYS = [\"tags\", \"metadata\", \"callbacks\", \"configurable\"];\n\nconst CONFIG_KEYS = [\n  \"tags\",\n  \"metadata\",\n  \"callbacks\",\n  \"runName\",\n  \"maxConcurrency\",\n  \"recursionLimit\",\n  \"configurable\",\n  \"runId\",\n  \"outputKeys\",\n  \"streamMode\",\n  \"store\",\n  \"writer\",\n];\n\nconst DEFAULT_RECURSION_LIMIT = 25;\n\nexport function ensureLangGraphConfig(\n  ...configs: (LangGraphRunnableConfig | undefined)[]\n): RunnableConfig {\n  const empty: LangGraphRunnableConfig = {\n    tags: [],\n    metadata: {},\n    callbacks: undefined,\n    recursionLimit: DEFAULT_RECURSION_LIMIT,\n    configurable: {},\n  };\n\n  const implicitConfig: RunnableConfig =\n    AsyncLocalStorageProviderSingleton.getRunnableConfig();\n  if (implicitConfig !== undefined) {\n    for (const [k, v] of Object.entries(implicitConfig)) {\n      if (v !== undefined) {\n        if (COPIABLE_KEYS.includes(k)) {\n          let copiedValue;\n          if (Array.isArray(v)) {\n            copiedValue = [...v];\n          } else if (typeof v === \"object\") {\n            if (\n              k === \"callbacks\" &&\n              \"copy\" in v &&\n              typeof v.copy === \"function\"\n            ) {\n              copiedValue = v.copy();\n            } else {\n              copiedValue = { ...v };\n            }\n          } else {\n            copiedValue = v;\n          }\n          empty[k as keyof RunnableConfig] = copiedValue;\n        } else {\n          empty[k as keyof RunnableConfig] = v;\n        }\n      }\n    }\n  }\n\n  for (const config of configs) {\n    if (config === undefined) {\n      continue;\n    }\n\n    for (const [k, v] of Object.entries(config)) {\n      if (v !== undefined && CONFIG_KEYS.includes(k)) {\n        empty[k as keyof LangGraphRunnableConfig] = v;\n      }\n    }\n  }\n\n  for (const [key, value] of Object.entries(empty.configurable!)) {\n    empty.metadata = empty.metadata ?? {};\n    if (\n      !key.startsWith(\"__\") &&\n      (typeof value === \"string\" ||\n        typeof value === \"number\" ||\n        typeof value === \"boolean\") &&\n      !(key in empty.metadata!)\n    ) {\n      empty.metadata[key] = value;\n    }\n  }\n\n  return empty;\n}\n",
    "last_modified": "Tue, 17 Dec 2024 17:05:28 GMT"
  },
  {
    "url": "https://github.com/langchain-ai/langgraphjs/blob/main/libs/langgraph/src/pregel/utils/index.ts",
    "markdown": "import { RunnableConfig } from \"@langchain/core/runnables\";\nimport type {\n  ChannelVersions,\n  CheckpointMetadata,\n} from \"@langchain/langgraph-checkpoint\";\nimport { CONFIG_KEY_CHECKPOINT_MAP } from \"../../constants.js\";\n\nexport function getNullChannelVersion(currentVersions: ChannelVersions) {\n  const versionValues = Object.values(currentVersions);\n  const versionType =\n    versionValues.length > 0 ? typeof versionValues[0] : undefined;\n  let nullVersion: number | string | undefined;\n  if (versionType === \"number\") {\n    nullVersion = 0;\n  } else if (versionType === \"string\") {\n    nullVersion = \"\";\n  }\n  return nullVersion;\n}\n\nexport function getNewChannelVersions(\n  previousVersions: ChannelVersions,\n  currentVersions: ChannelVersions\n): ChannelVersions {\n  // Get new channel versions\n  if (Object.keys(previousVersions).length > 0) {\n    const nullVersion = getNullChannelVersion(currentVersions);\n    return Object.fromEntries(\n      Object.entries(currentVersions).filter(\n        ([k, v]) => v > (previousVersions[k] ?? nullVersion)\n      )\n    );\n  } else {\n    return currentVersions;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function _coerceToDict(value: any, defaultKey: string) {\n  return value &&\n    !Array.isArray(value) &&\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    !(value instanceof Date) &&\n    typeof value === \"object\"\n    ? value\n    : { [defaultKey]: value };\n}\n\nexport type RetryPolicy = {\n  /**\n   * Amount of time that must elapse before the first retry occurs in milliseconds.\n   * @default 500\n   */\n  initialInterval?: number;\n  /**\n   * Multiplier by which the interval increases after each retry.\n   * @default 2\n   */\n  backoffFactor?: number;\n  /**\n   * Maximum amount of time that may elapse between retries in milliseconds.\n   * @default 128000\n   */\n  maxInterval?: number;\n  /**\n   * Maximum amount of time that may elapse between retries.\n   * @default 3\n   */\n  maxAttempts?: number;\n  /** Whether to add random jitter to the interval between retries. */\n  jitter?: boolean;\n  /** A function that returns True for exceptions that should trigger a retry. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  retryOn?: (e: any) => boolean;\n};\n\nexport function patchConfigurable(\n  config: RunnableConfig | undefined,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  patch: Record<string, any>\n): RunnableConfig {\n  if (config === null) {\n    return { configurable: patch };\n  } else if (config?.configurable === undefined) {\n    return { ...config, configurable: patch };\n  } else {\n    return {\n      ...config,\n      configurable: { ...config.configurable, ...patch },\n    };\n  }\n}\n\nexport function patchCheckpointMap(\n  config: RunnableConfig,\n  metadata?: CheckpointMetadata\n): RunnableConfig {\n  const parents = metadata?.parents ?? {};\n\n  if (Object.keys(parents).length > 0) {\n    return patchConfigurable(config, {\n      [CONFIG_KEY_CHECKPOINT_MAP]: {\n        ...parents,\n        [config.configurable?.checkpoint_ns ?? \"\"]:\n          config.configurable?.checkpoint_id,\n      },\n    });\n  } else {\n    return config;\n  }\n}\n",
    "last_modified": "Tue, 17 Dec 2024 17:05:28 GMT"
  },
  {
    "url": "https://github.com/langchain-ai/langgraphjs/blob/main/libs/langgraph/src/pregel/utils/subgraph.ts",
    "markdown": "import {\n  RunnableSequence,\n  Runnable,\n  RunnableLike,\n} from \"@langchain/core/runnables\";\nimport type { PregelInterface } from \"../types.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isRunnableSequence(\n  x: RunnableSequence | Runnable\n): x is RunnableSequence {\n  return \"steps\" in x && Array.isArray(x.steps);\n}\n\nexport function isPregelLike(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  x: PregelInterface<any, any> | RunnableLike<any, any, any>\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): x is PregelInterface<any, any> {\n  return \"lg_is_pregel\" in x && x.lg_is_pregel === true;\n}\n\nexport function findSubgraphPregel(\n  candidate: Runnable\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): PregelInterface<any, any> | undefined {\n  const candidates = [candidate];\n  for (const candidate of candidates) {\n    if (isPregelLike(candidate)) {\n      return candidate;\n    } else if (isRunnableSequence(candidate)) {\n      candidates.push(...candidate.steps);\n    }\n  }\n  return undefined;\n}\n",
    "last_modified": "Tue, 17 Dec 2024 17:05:28 GMT"
  }
]